/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/IsTenantAvailable';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsTenantAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsTenantAvailable(<any>response_);
            } catch (e) {
              return <Observable<IsTenantAvailableOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<IsTenantAvailableOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IsTenantAvailableOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<IsTenantAvailableOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: UserDto | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/Register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_);
            } catch (e) {
              return <Observable<RegisterOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<RegisterOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RegisterOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RegisterOutput>(<any>null);
  }
}

@Injectable()
export class ConfigurationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Configuration/ChangeUiTheme';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeUiTheme(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeUiTheme(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class DomainActionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @param eventTypeId (optional)
   * @param subscriptionTypeId (optional)
   * @param subscriptionInstanceId (optional)
   * @param organisationId (optional)
   * @param automatic (optional)
   * @param active (optional)
   * @param command (optional)
   * @param type (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    id: number | undefined,
    eventTypeId: number | undefined,
    subscriptionTypeId: number | undefined,
    subscriptionInstanceId: number | undefined,
    organisationId: number | undefined,
    automatic: boolean | undefined,
    active: boolean | undefined,
    command: string | undefined,
    type: ActionType | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<DomainActionDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/DomainAction/GetAll?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (eventTypeId === null) throw new Error("The parameter 'eventTypeId' cannot be null.");
    else if (eventTypeId !== undefined) url_ += 'EventTypeId=' + encodeURIComponent('' + eventTypeId) + '&';
    if (subscriptionTypeId === null) throw new Error("The parameter 'subscriptionTypeId' cannot be null.");
    else if (subscriptionTypeId !== undefined)
      url_ += 'SubscriptionTypeId=' + encodeURIComponent('' + subscriptionTypeId) + '&';
    if (subscriptionInstanceId === null) throw new Error("The parameter 'subscriptionInstanceId' cannot be null.");
    else if (subscriptionInstanceId !== undefined)
      url_ += 'SubscriptionInstanceId=' + encodeURIComponent('' + subscriptionInstanceId) + '&';
    if (organisationId === null) throw new Error("The parameter 'organisationId' cannot be null.");
    else if (organisationId !== undefined) url_ += 'OrganisationId=' + encodeURIComponent('' + organisationId) + '&';
    if (automatic === null) throw new Error("The parameter 'automatic' cannot be null.");
    else if (automatic !== undefined) url_ += 'Automatic=' + encodeURIComponent('' + automatic) + '&';
    if (active === null) throw new Error("The parameter 'active' cannot be null.");
    else if (active !== undefined) url_ += 'Active=' + encodeURIComponent('' + active) + '&';
    if (command === null) throw new Error("The parameter 'command' cannot be null.");
    else if (command !== undefined) url_ += 'Command=' + encodeURIComponent('' + command) + '&';
    if (type === null) throw new Error("The parameter 'type' cannot be null.");
    else if (type !== undefined) url_ += 'Type=' + encodeURIComponent('' + type) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<DomainActionDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DomainActionDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<DomainActionDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DomainActionDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DomainActionDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<DomainActionDto> {
    let url_ = this.baseUrl + '/api/services/app/DomainAction/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<DomainActionDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DomainActionDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<DomainActionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DomainActionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DomainActionDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: DomainActionDto | undefined): Observable<DomainActionDto> {
    let url_ = this.baseUrl + '/api/services/app/DomainAction/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<DomainActionDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DomainActionDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<DomainActionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DomainActionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DomainActionDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: DomainActionDto | undefined): Observable<DomainActionDto> {
    let url_ = this.baseUrl + '/api/services/app/DomainAction/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<DomainActionDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DomainActionDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<DomainActionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DomainActionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DomainActionDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DomainAction/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EventServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param range (optional)
   * @param organisationId (optional)
   * @param resourceId (optional)
   * @param startDate (optional)
   * @param withFreeSlots (optional)
   * @param expandAll (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    range: EventSearchRange | undefined,
    organisationId: number | undefined,
    resourceId: number | undefined,
    startDate: moment.Moment | undefined,
    withFreeSlots: boolean | undefined,
    expandAll: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EventDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Event/GetAll?';
    if (range === null) throw new Error("The parameter 'range' cannot be null.");
    else if (range !== undefined) url_ += 'Range=' + encodeURIComponent('' + range) + '&';
    if (organisationId === null) throw new Error("The parameter 'organisationId' cannot be null.");
    else if (organisationId !== undefined) url_ += 'organisationId=' + encodeURIComponent('' + organisationId) + '&';
    if (resourceId === null) throw new Error("The parameter 'resourceId' cannot be null.");
    else if (resourceId !== undefined) url_ += 'resourceId=' + encodeURIComponent('' + resourceId) + '&';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined)
      url_ += 'startDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (withFreeSlots === null) throw new Error("The parameter 'withFreeSlots' cannot be null.");
    else if (withFreeSlots !== undefined) url_ += 'withFreeSlots=' + encodeURIComponent('' + withFreeSlots) + '&';
    if (expandAll === null) throw new Error("The parameter 'expandAll' cannot be null.");
    else if (expandAll !== undefined) url_ += 'expandAll=' + encodeURIComponent('' + expandAll) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EventDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<EventDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: string | undefined): Observable<EventDto> {
    let url_ = this.baseUrl + '/api/services/app/Event/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EventDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EventDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: EventDto | undefined): Observable<EventDto> {
    let url_ = this.baseUrl + '/api/services/app/Event/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<EventDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<EventDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EventDto | undefined): Observable<EventDto> {
    let url_ = this.baseUrl + '/api/services/app/Event/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EventDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<EventDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: string | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Event/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EventTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EventTypeDto> {
    let url_ = this.baseUrl + '/api/services/app/EventType/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EventTypeDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EventTypeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeDto>(<any>null);
  }

  /**
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    sorting: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EventTypeDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/EventType/GetAll?';
    if (sorting === null) throw new Error("The parameter 'sorting' cannot be null.");
    else if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EventTypeDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<EventTypeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: EventTypeDto | undefined): Observable<EventTypeDto> {
    let url_ = this.baseUrl + '/api/services/app/EventType/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<EventTypeDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<EventTypeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EventTypeDto | undefined): Observable<EventTypeDto> {
    let url_ = this.baseUrl + '/api/services/app/EventType/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EventTypeDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<EventTypeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EventType/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EventTypeCRUDServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EventTypeCRUDDto> {
    let url_ = this.baseUrl + '/api/services/app/EventTypeCRUD/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EventTypeCRUDDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeCRUDDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EventTypeCRUDDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeCRUDDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeCRUDDto>(<any>null);
  }

  /**
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    sorting: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EventTypeCRUDDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/EventTypeCRUD/GetAll?';
    if (sorting === null) throw new Error("The parameter 'sorting' cannot be null.");
    else if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EventTypeCRUDDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeCRUDDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<EventTypeCRUDDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeCRUDDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeCRUDDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: EventTypeCRUDDto | undefined): Observable<EventTypeCRUDDto> {
    let url_ = this.baseUrl + '/api/services/app/EventTypeCRUD/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<EventTypeCRUDDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeCRUDDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<EventTypeCRUDDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeCRUDDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeCRUDDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EventTypeCRUDDto | undefined): Observable<EventTypeCRUDDto> {
    let url_ = this.baseUrl + '/api/services/app/EventTypeCRUD/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EventTypeCRUDDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EventTypeCRUDDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<EventTypeCRUDDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EventTypeCRUDDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EventTypeCRUDDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EventTypeCRUD/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class OrganisationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<OrganisationDto> {
    let url_ = this.baseUrl + '/api/services/app/Organisation/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<OrganisationDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<OrganisationDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<OrganisationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrganisationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OrganisationDto>(<any>null);
  }

  /**
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    sorting: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<OrganisationDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Organisation/GetAll?';
    if (sorting === null) throw new Error("The parameter 'sorting' cannot be null.");
    else if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<OrganisationDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<OrganisationDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<OrganisationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrganisationDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OrganisationDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: OrganisationDto | undefined): Observable<OrganisationDto> {
    let url_ = this.baseUrl + '/api/services/app/Organisation/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<OrganisationDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<OrganisationDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<OrganisationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrganisationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OrganisationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: OrganisationDto | undefined): Observable<OrganisationDto> {
    let url_ = this.baseUrl + '/api/services/app/Organisation/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<OrganisationDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<OrganisationDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<OrganisationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrganisationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OrganisationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Organisation/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class PaymentGatewayServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  initiatePayment(body: PaymentRequestDto | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/services/app/PaymentGateway/InitiatePayment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInitiatePayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInitiatePayment(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processInitiatePayment(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  completePayment(body: PaymentRequestDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/PaymentGateway/CompletePayment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCompletePayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCompletePayment(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCompletePayment(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<PaymentGatewayDto> {
    let url_ = this.baseUrl + '/api/services/app/PaymentGateway/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<PaymentGatewayDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PaymentGatewayDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<PaymentGatewayDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentGatewayDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PaymentGatewayDto>(<any>null);
  }

  /**
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    sorting: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PaymentGatewayDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/PaymentGateway/GetAll?';
    if (sorting === null) throw new Error("The parameter 'sorting' cannot be null.");
    else if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PaymentGatewayDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PaymentGatewayDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PaymentGatewayDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentGatewayDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PaymentGatewayDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: PaymentGatewayDto | undefined): Observable<PaymentGatewayDto> {
    let url_ = this.baseUrl + '/api/services/app/PaymentGateway/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<PaymentGatewayDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PaymentGatewayDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<PaymentGatewayDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentGatewayDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PaymentGatewayDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: PaymentGatewayDto | undefined): Observable<PaymentGatewayDto> {
    let url_ = this.baseUrl + '/api/services/app/PaymentGateway/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<PaymentGatewayDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PaymentGatewayDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<PaymentGatewayDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentGatewayDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PaymentGatewayDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PaymentGateway/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ResourceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<ResourceDto> {
    let url_ = this.baseUrl + '/api/services/app/Resource/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ResourceDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ResourceDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ResourceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResourceDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ResourceDto>(<any>null);
  }

  /**
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    sorting: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ResourceDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Resource/GetAll?';
    if (sorting === null) throw new Error("The parameter 'sorting' cannot be null.");
    else if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ResourceDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ResourceDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ResourceDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResourceDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ResourceDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: ResourceDto | undefined): Observable<ResourceDto> {
    let url_ = this.baseUrl + '/api/services/app/Resource/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<ResourceDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ResourceDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<ResourceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResourceDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ResourceDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: ResourceDto | undefined): Observable<ResourceDto> {
    let url_ = this.baseUrl + '/api/services/app/Resource/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<ResourceDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ResourceDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<ResourceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResourceDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ResourceDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Resource/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class RoleServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateRoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + '/api/services/app/Role/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param permission (optional)
   * @return Success
   */
  getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Role/GetRoles?';
    if (permission === null) throw new Error("The parameter 'permission' cannot be null.");
    else if (permission !== undefined) url_ += 'Permission=' + encodeURIComponent('' + permission) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(<any>response_);
            } catch (e) {
              return <Observable<RoleListDtoListResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleListDtoListResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleListDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoleListDtoListResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: RoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + '/api/services/app/Role/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Role/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPermissions(): Observable<PermissionDtoListResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Role/GetAllPermissions';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPermissions(<any>response_);
            } catch (e) {
              return <Observable<PermissionDtoListResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PermissionDtoListResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PermissionDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PermissionDtoListResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Role/GetRoleForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoleForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoleForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetRoleForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRoleForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoleForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRoleForEditOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + '/api/services/app/Role/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RoleDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Role/GetAll?';
    if (keyword === null) throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined) url_ += 'Keyword=' + encodeURIComponent('' + keyword) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<RoleDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoleDtoPagedResultDto>(<any>null);
  }
}

@Injectable()
export class SessionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
    let url_ = this.baseUrl + '/api/services/app/Session/GetCurrentLoginInformations';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentLoginInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentLoginInformations(<any>response_);
            } catch (e) {
              return <Observable<GetCurrentLoginInformationsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCurrentLoginInformationsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCurrentLoginInformations(
    response: HttpResponseBase
  ): Observable<GetCurrentLoginInformationsOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
  }
}

@Injectable()
export class SubscriptionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param organisationId (optional)
   * @param id (optional)
   * @param userId (optional)
   * @param activeOnly (optional)
   * @param activePer (optional)
   * @param eventType (optional)
   * @param prepaidOnly (optional)
   * @param postingsBalanced (optional)
   * @param subscriptionTypeId (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    organisationId: number | undefined,
    id: number | undefined,
    userId: number | undefined,
    activeOnly: boolean | undefined,
    activePer: moment.Moment | undefined,
    eventType: number | undefined,
    prepaidOnly: boolean | undefined,
    postingsBalanced: boolean | undefined,
    subscriptionTypeId: number | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<SubscriptionDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Subscription/GetAll?';
    if (organisationId === null) throw new Error("The parameter 'organisationId' cannot be null.");
    else if (organisationId !== undefined) url_ += 'OrganisationId=' + encodeURIComponent('' + organisationId) + '&';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += 'UserId=' + encodeURIComponent('' + userId) + '&';
    if (activeOnly === null) throw new Error("The parameter 'activeOnly' cannot be null.");
    else if (activeOnly !== undefined) url_ += 'ActiveOnly=' + encodeURIComponent('' + activeOnly) + '&';
    if (activePer === null) throw new Error("The parameter 'activePer' cannot be null.");
    else if (activePer !== undefined)
      url_ += 'ActivePer=' + encodeURIComponent(activePer ? '' + activePer.toJSON() : '') + '&';
    if (eventType === null) throw new Error("The parameter 'eventType' cannot be null.");
    else if (eventType !== undefined) url_ += 'EventType=' + encodeURIComponent('' + eventType) + '&';
    if (prepaidOnly === null) throw new Error("The parameter 'prepaidOnly' cannot be null.");
    else if (prepaidOnly !== undefined) url_ += 'PrepaidOnly=' + encodeURIComponent('' + prepaidOnly) + '&';
    if (postingsBalanced === null) throw new Error("The parameter 'postingsBalanced' cannot be null.");
    else if (postingsBalanced !== undefined)
      url_ += 'PostingsBalanced=' + encodeURIComponent('' + postingsBalanced) + '&';
    if (subscriptionTypeId === null) throw new Error("The parameter 'subscriptionTypeId' cannot be null.");
    else if (subscriptionTypeId !== undefined)
      url_ += 'SubscriptionTypeId=' + encodeURIComponent('' + subscriptionTypeId) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<SubscriptionDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<SubscriptionDto> {
    let url_ = this.baseUrl + '/api/services/app/Subscription/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SubscriptionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: SubscriptionDto | undefined): Observable<SubscriptionDto> {
    let url_ = this.baseUrl + '/api/services/app/Subscription/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<SubscriptionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: SubscriptionDto | undefined): Observable<SubscriptionDto> {
    let url_ = this.baseUrl + '/api/services/app/Subscription/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<SubscriptionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Subscription/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class SubscriptionTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<SubscriptionTypeDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionType/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SubscriptionTypeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @param organisationId (optional)
   * @param prepaid (optional)
   * @param eventTypeId (optional)
   * @param bookableOnly (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    id: number | undefined,
    organisationId: number | undefined,
    prepaid: boolean | undefined,
    eventTypeId: number | undefined,
    bookableOnly: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<SubscriptionTypeDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionType/GetAll?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (organisationId === null) throw new Error("The parameter 'organisationId' cannot be null.");
    else if (organisationId !== undefined) url_ += 'OrganisationId=' + encodeURIComponent('' + organisationId) + '&';
    if (prepaid === null) throw new Error("The parameter 'prepaid' cannot be null.");
    else if (prepaid !== undefined) url_ += 'Prepaid=' + encodeURIComponent('' + prepaid) + '&';
    if (eventTypeId === null) throw new Error("The parameter 'eventTypeId' cannot be null.");
    else if (eventTypeId !== undefined) url_ += 'EventTypeId=' + encodeURIComponent('' + eventTypeId) + '&';
    if (bookableOnly === null) throw new Error("The parameter 'bookableOnly' cannot be null.");
    else if (bookableOnly !== undefined) url_ += 'bookableOnly=' + encodeURIComponent('' + bookableOnly) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<SubscriptionTypeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: SubscriptionTypeDto | undefined): Observable<SubscriptionTypeDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionType/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<SubscriptionTypeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: SubscriptionTypeDto | undefined): Observable<SubscriptionTypeDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionType/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<SubscriptionTypeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionType/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class SubscriptionTypeCRUDServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<SubscriptionTypeCRUDDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionTypeCRUD/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeCRUDDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeCRUDDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SubscriptionTypeCRUDDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeCRUDDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeCRUDDto>(<any>null);
  }

  /**
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    sorting: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<SubscriptionTypeCRUDDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionTypeCRUD/GetAll?';
    if (sorting === null) throw new Error("The parameter 'sorting' cannot be null.");
    else if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeCRUDDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeCRUDDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<SubscriptionTypeCRUDDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeCRUDDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeCRUDDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: SubscriptionTypeCRUDDto | undefined): Observable<SubscriptionTypeCRUDDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionTypeCRUD/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeCRUDDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeCRUDDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<SubscriptionTypeCRUDDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeCRUDDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeCRUDDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: SubscriptionTypeCRUDDto | undefined): Observable<SubscriptionTypeCRUDDto> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionTypeCRUD/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionTypeCRUDDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionTypeCRUDDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<SubscriptionTypeCRUDDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionTypeCRUDDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionTypeCRUDDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/SubscriptionTypeCRUD/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TenantServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateTenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<TenantDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/GetAll?';
    if (keyword === null) throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined) url_ += 'Keyword=' + encodeURIComponent('' + keyword) + '&';
    if (isActive === null) throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined) url_ += 'IsActive=' + encodeURIComponent('' + isActive) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<TenantDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: TenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/Authenticate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<AuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<AuthenticateResultModel>(<any>null);
  }

  /**
   * @param token (optional)
   * @param refreshToken (optional)
   * @return Success
   */
  refresh(token: string | undefined, refreshToken: string | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/TokenAuth/Refresh?';
    if (token === null) throw new Error("The parameter 'token' cannot be null.");
    else if (token !== undefined) url_ += 'token=' + encodeURIComponent('' + token) + '&';
    if (refreshToken === null) throw new Error("The parameter 'refreshToken' cannot be null.");
    else if (refreshToken !== undefined) url_ += 'refreshToken=' + encodeURIComponent('' + refreshToken) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefresh(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefresh(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRefresh(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
    let url_ = this.baseUrl + '/api/TokenAuth/GetExternalAuthenticationProviders';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExternalAuthenticationProviders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExternalAuthenticationProviders(<any>response_);
            } catch (e) {
              return <Observable<ExternalLoginProviderInfoModel[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ExternalLoginProviderInfoModel[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetExternalAuthenticationProviders(
    response: HttpResponseBase
  ): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/ExternalAuthenticate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<ExternalAuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<ExternalAuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ExternalAuthenticateResultModel>(<any>null);
  }
}

@Injectable()
export class UserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateUserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + '/api/services/app/User/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + '/api/services/app/User/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/User/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getRoles(): Observable<RoleDtoListResultDto> {
    let url_ = this.baseUrl + '/api/services/app/User/GetRoles';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(<any>response_);
            } catch (e) {
              return <Observable<RoleDtoListResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDtoListResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoleDtoListResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/User/ChangeLanguage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/User/ChangePassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/User/ResetPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + '/api/services/app/User/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<UserDtoPagedResultDto> {
    let url_ = this.baseUrl + '/api/services/app/User/GetAll?';
    if (keyword === null) throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined) url_ += 'Keyword=' + encodeURIComponent('' + keyword) + '&';
    if (isActive === null) throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined) url_ += 'IsActive=' + encodeURIComponent('' + isActive) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain'
      })
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UserDtoPagedResultDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDtoPagedResultDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UserDtoPagedResultDto>(<any>null);
  }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
  tenancyName!: string | undefined;

  constructor(data?: IIsTenantAvailableInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
    }
  }

  static fromJS(data: any): IsTenantAvailableInput {
    data = typeof data === 'object' ? data : {};
    let result = new IsTenantAvailableInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    return data;
  }

  clone(): IsTenantAvailableInput {
    const json = this.toJSON();
    let result = new IsTenantAvailableInput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableInput {
  tenancyName: string | undefined;
}

export enum TenantAvailabilityState {
  _1 = 1,
  _2 = 2,
  _3 = 3
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
  state?: TenantAvailabilityState;
  tenantId?: number | undefined;

  constructor(data?: IIsTenantAvailableOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data['state'];
      this.tenantId = _data['tenantId'];
    }
  }

  static fromJS(data: any): IsTenantAvailableOutput {
    data = typeof data === 'object' ? data : {};
    let result = new IsTenantAvailableOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['state'] = this.state;
    data['tenantId'] = this.tenantId;
    return data;
  }

  clone(): IsTenantAvailableOutput {
    const json = this.toJSON();
    let result = new IsTenantAvailableOutput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableOutput {
  state?: TenantAvailabilityState;
  tenantId?: number | undefined;
}

export class UserToken implements IUserToken {
  tenantId?: number | undefined;
  userId?: number;
  loginProvider?: string | undefined;
  name?: string | undefined;
  value?: string | undefined;
  expireDate?: moment.Moment | undefined;
  id?: number;

  constructor(data?: IUserToken) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
      this.loginProvider = _data['loginProvider'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.expireDate = _data['expireDate'] ? moment(_data['expireDate'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserToken {
    data = typeof data === 'object' ? data : {};
    let result = new UserToken();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    data['loginProvider'] = this.loginProvider;
    data['name'] = this.name;
    data['value'] = this.value;
    data['expireDate'] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }

  clone(): UserToken {
    const json = this.toJSON();
    let result = new UserToken();
    result.init(json);
    return result;
  }
}

export interface IUserToken {
  tenantId?: number | undefined;
  userId?: number;
  loginProvider?: string | undefined;
  name?: string | undefined;
  value?: string | undefined;
  expireDate?: moment.Moment | undefined;
  id?: number;
}

export class UserLogin implements IUserLogin {
  tenantId?: number | undefined;
  userId?: number;
  loginProvider!: string | undefined;
  providerKey!: string | undefined;
  id?: number;

  constructor(data?: IUserLogin) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
      this.loginProvider = _data['loginProvider'];
      this.providerKey = _data['providerKey'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserLogin {
    data = typeof data === 'object' ? data : {};
    let result = new UserLogin();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    data['loginProvider'] = this.loginProvider;
    data['providerKey'] = this.providerKey;
    data['id'] = this.id;
    return data;
  }

  clone(): UserLogin {
    const json = this.toJSON();
    let result = new UserLogin();
    result.init(json);
    return result;
  }
}

export interface IUserLogin {
  tenantId?: number | undefined;
  userId?: number;
  loginProvider: string | undefined;
  providerKey: string | undefined;
  id?: number;
}

export class UserRole implements IUserRole {
  tenantId?: number | undefined;
  userId?: number;
  roleId?: number;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;

  constructor(data?: IUserRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
      this.roleId = _data['roleId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserRole {
    data = typeof data === 'object' ? data : {};
    let result = new UserRole();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    data['roleId'] = this.roleId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }

  clone(): UserRole {
    const json = this.toJSON();
    let result = new UserRole();
    result.init(json);
    return result;
  }
}

export interface IUserRole {
  tenantId?: number | undefined;
  userId?: number;
  roleId?: number;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;
}

export class UserClaim implements IUserClaim {
  tenantId?: number | undefined;
  userId?: number;
  claimType?: string | undefined;
  claimValue?: string | undefined;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;

  constructor(data?: IUserClaim) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
      this.claimType = _data['claimType'];
      this.claimValue = _data['claimValue'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserClaim {
    data = typeof data === 'object' ? data : {};
    let result = new UserClaim();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    data['claimType'] = this.claimType;
    data['claimValue'] = this.claimValue;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }

  clone(): UserClaim {
    const json = this.toJSON();
    let result = new UserClaim();
    result.init(json);
    return result;
  }
}

export interface IUserClaim {
  tenantId?: number | undefined;
  userId?: number;
  claimType?: string | undefined;
  claimValue?: string | undefined;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
  userId?: number;
  tenantId?: number | undefined;
  name!: string | undefined;
  isGranted?: boolean;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;

  constructor(data?: IUserPermissionSetting) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.tenantId = _data['tenantId'];
      this.name = _data['name'];
      this.isGranted = _data['isGranted'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserPermissionSetting {
    data = typeof data === 'object' ? data : {};
    let result = new UserPermissionSetting();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['tenantId'] = this.tenantId;
    data['name'] = this.name;
    data['isGranted'] = this.isGranted;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }

  clone(): UserPermissionSetting {
    const json = this.toJSON();
    let result = new UserPermissionSetting();
    result.init(json);
    return result;
  }
}

export interface IUserPermissionSetting {
  userId?: number;
  tenantId?: number | undefined;
  name: string | undefined;
  isGranted?: boolean;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;
}

export class Setting implements ISetting {
  tenantId?: number | undefined;
  userId?: number | undefined;
  name!: string | undefined;
  value?: string | undefined;
  lastModificationTime?: moment.Moment | undefined;
  lastModifierUserId?: number | undefined;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;

  constructor(data?: ISetting) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.lastModificationTime = _data['lastModificationTime']
        ? moment(_data['lastModificationTime'].toString())
        : <any>undefined;
      this.lastModifierUserId = _data['lastModifierUserId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): Setting {
    data = typeof data === 'object' ? data : {};
    let result = new Setting();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    data['name'] = this.name;
    data['value'] = this.value;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data['lastModifierUserId'] = this.lastModifierUserId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }

  clone(): Setting {
    const json = this.toJSON();
    let result = new Setting();
    result.init(json);
    return result;
  }
}

export interface ISetting {
  tenantId?: number | undefined;
  userId?: number | undefined;
  name: string | undefined;
  value?: string | undefined;
  lastModificationTime?: moment.Moment | undefined;
  lastModifierUserId?: number | undefined;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;
}

export class User implements IUser {
  companyName?: string | undefined;
  birthdate?: moment.Moment | undefined;
  avatar?: string | undefined;
  gender?: string | undefined;
  student?: boolean;
  studentConfirmedDate?: moment.Moment | undefined;
  studentLegitimation?: string | undefined;
  lastActivityDate?: moment.Moment | undefined;
  registrationDate?: moment.Moment | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  externalId?: string | undefined;
  intId?: number;
  externalSystem?: string | undefined;
  secondaryEmail?: string | undefined;
  normalizedUserName!: string | undefined;
  normalizedEmailAddress!: string | undefined;
  concurrencyStamp?: string | undefined;
  tokens?: UserToken[] | undefined;
  deleterUser?: User;
  creatorUser?: User;
  lastModifierUser?: User;
  authenticationSource?: string | undefined;
  userName!: string | undefined;
  tenantId?: number | undefined;
  emailAddress!: string | undefined;
  name!: string | undefined;
  surname!: string | undefined;
  readonly fullName?: string | undefined;
  password!: string | undefined;
  emailConfirmationCode?: string | undefined;
  passwordResetCode?: string | undefined;
  lockoutEndDateUtc?: moment.Moment | undefined;
  accessFailedCount?: number;
  isLockoutEnabled?: boolean;
  phoneNumber?: string | undefined;
  isPhoneNumberConfirmed?: boolean;
  securityStamp?: string | undefined;
  isTwoFactorEnabled?: boolean;
  logins?: UserLogin[] | undefined;
  roles?: UserRole[] | undefined;
  claims?: UserClaim[] | undefined;
  permissions?: UserPermissionSetting[] | undefined;
  settings?: Setting[] | undefined;
  isEmailConfirmed?: boolean;
  isActive?: boolean;
  isDeleted?: boolean;
  deleterUserId?: number | undefined;
  deletionTime?: moment.Moment | undefined;
  lastModificationTime?: moment.Moment | undefined;
  lastModifierUserId?: number | undefined;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.companyName = _data['companyName'];
      this.birthdate = _data['birthdate'] ? moment(_data['birthdate'].toString()) : <any>undefined;
      this.avatar = _data['avatar'];
      this.gender = _data['gender'];
      this.student = _data['student'];
      this.studentConfirmedDate = _data['studentConfirmedDate']
        ? moment(_data['studentConfirmedDate'].toString())
        : <any>undefined;
      this.studentLegitimation = _data['studentLegitimation'];
      this.lastActivityDate = _data['lastActivityDate'] ? moment(_data['lastActivityDate'].toString()) : <any>undefined;
      this.registrationDate = _data['registrationDate'] ? moment(_data['registrationDate'].toString()) : <any>undefined;
      this.address = _data['address'];
      this.postalCode = _data['postalCode'];
      this.city = _data['city'];
      this.country = _data['country'];
      this.externalId = _data['externalId'];
      this.intId = _data['intId'];
      this.externalSystem = _data['externalSystem'];
      this.secondaryEmail = _data['secondaryEmail'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.normalizedEmailAddress = _data['normalizedEmailAddress'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      if (Array.isArray(_data['tokens'])) {
        this.tokens = [] as any;
        for (let item of _data['tokens']) this.tokens!.push(UserToken.fromJS(item));
      }
      this.deleterUser = _data['deleterUser'] ? User.fromJS(_data['deleterUser']) : <any>undefined;
      this.creatorUser = _data['creatorUser'] ? User.fromJS(_data['creatorUser']) : <any>undefined;
      this.lastModifierUser = _data['lastModifierUser'] ? User.fromJS(_data['lastModifierUser']) : <any>undefined;
      this.authenticationSource = _data['authenticationSource'];
      this.userName = _data['userName'];
      this.tenantId = _data['tenantId'];
      this.emailAddress = _data['emailAddress'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      (<any>this).fullName = _data['fullName'];
      this.password = _data['password'];
      this.emailConfirmationCode = _data['emailConfirmationCode'];
      this.passwordResetCode = _data['passwordResetCode'];
      this.lockoutEndDateUtc = _data['lockoutEndDateUtc']
        ? moment(_data['lockoutEndDateUtc'].toString())
        : <any>undefined;
      this.accessFailedCount = _data['accessFailedCount'];
      this.isLockoutEnabled = _data['isLockoutEnabled'];
      this.phoneNumber = _data['phoneNumber'];
      this.isPhoneNumberConfirmed = _data['isPhoneNumberConfirmed'];
      this.securityStamp = _data['securityStamp'];
      this.isTwoFactorEnabled = _data['isTwoFactorEnabled'];
      if (Array.isArray(_data['logins'])) {
        this.logins = [] as any;
        for (let item of _data['logins']) this.logins!.push(UserLogin.fromJS(item));
      }
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(UserRole.fromJS(item));
      }
      if (Array.isArray(_data['claims'])) {
        this.claims = [] as any;
        for (let item of _data['claims']) this.claims!.push(UserClaim.fromJS(item));
      }
      if (Array.isArray(_data['permissions'])) {
        this.permissions = [] as any;
        for (let item of _data['permissions']) this.permissions!.push(UserPermissionSetting.fromJS(item));
      }
      if (Array.isArray(_data['settings'])) {
        this.settings = [] as any;
        for (let item of _data['settings']) this.settings!.push(Setting.fromJS(item));
      }
      this.isEmailConfirmed = _data['isEmailConfirmed'];
      this.isActive = _data['isActive'];
      this.isDeleted = _data['isDeleted'];
      this.deleterUserId = _data['deleterUserId'];
      this.deletionTime = _data['deletionTime'] ? moment(_data['deletionTime'].toString()) : <any>undefined;
      this.lastModificationTime = _data['lastModificationTime']
        ? moment(_data['lastModificationTime'].toString())
        : <any>undefined;
      this.lastModifierUserId = _data['lastModifierUserId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['companyName'] = this.companyName;
    data['birthdate'] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
    data['avatar'] = this.avatar;
    data['gender'] = this.gender;
    data['student'] = this.student;
    data['studentConfirmedDate'] = this.studentConfirmedDate ? this.studentConfirmedDate.toISOString() : <any>undefined;
    data['studentLegitimation'] = this.studentLegitimation;
    data['lastActivityDate'] = this.lastActivityDate ? this.lastActivityDate.toISOString() : <any>undefined;
    data['registrationDate'] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
    data['address'] = this.address;
    data['postalCode'] = this.postalCode;
    data['city'] = this.city;
    data['country'] = this.country;
    data['externalId'] = this.externalId;
    data['intId'] = this.intId;
    data['externalSystem'] = this.externalSystem;
    data['secondaryEmail'] = this.secondaryEmail;
    data['normalizedUserName'] = this.normalizedUserName;
    data['normalizedEmailAddress'] = this.normalizedEmailAddress;
    data['concurrencyStamp'] = this.concurrencyStamp;
    if (Array.isArray(this.tokens)) {
      data['tokens'] = [];
      for (let item of this.tokens) data['tokens'].push(item.toJSON());
    }
    data['deleterUser'] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
    data['creatorUser'] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
    data['lastModifierUser'] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
    data['authenticationSource'] = this.authenticationSource;
    data['userName'] = this.userName;
    data['tenantId'] = this.tenantId;
    data['emailAddress'] = this.emailAddress;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['fullName'] = this.fullName;
    data['password'] = this.password;
    data['emailConfirmationCode'] = this.emailConfirmationCode;
    data['passwordResetCode'] = this.passwordResetCode;
    data['lockoutEndDateUtc'] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
    data['accessFailedCount'] = this.accessFailedCount;
    data['isLockoutEnabled'] = this.isLockoutEnabled;
    data['phoneNumber'] = this.phoneNumber;
    data['isPhoneNumberConfirmed'] = this.isPhoneNumberConfirmed;
    data['securityStamp'] = this.securityStamp;
    data['isTwoFactorEnabled'] = this.isTwoFactorEnabled;
    if (Array.isArray(this.logins)) {
      data['logins'] = [];
      for (let item of this.logins) data['logins'].push(item.toJSON());
    }
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item.toJSON());
    }
    if (Array.isArray(this.claims)) {
      data['claims'] = [];
      for (let item of this.claims) data['claims'].push(item.toJSON());
    }
    if (Array.isArray(this.permissions)) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item.toJSON());
    }
    if (Array.isArray(this.settings)) {
      data['settings'] = [];
      for (let item of this.settings) data['settings'].push(item.toJSON());
    }
    data['isEmailConfirmed'] = this.isEmailConfirmed;
    data['isActive'] = this.isActive;
    data['isDeleted'] = this.isDeleted;
    data['deleterUserId'] = this.deleterUserId;
    data['deletionTime'] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data['lastModifierUserId'] = this.lastModifierUserId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }

  clone(): User {
    const json = this.toJSON();
    let result = new User();
    result.init(json);
    return result;
  }
}

export interface IUser {
  companyName?: string | undefined;
  birthdate?: moment.Moment | undefined;
  avatar?: string | undefined;
  gender?: string | undefined;
  student?: boolean;
  studentConfirmedDate?: moment.Moment | undefined;
  studentLegitimation?: string | undefined;
  lastActivityDate?: moment.Moment | undefined;
  registrationDate?: moment.Moment | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  externalId?: string | undefined;
  intId?: number;
  externalSystem?: string | undefined;
  secondaryEmail?: string | undefined;
  normalizedUserName: string | undefined;
  normalizedEmailAddress: string | undefined;
  concurrencyStamp?: string | undefined;
  tokens?: UserToken[] | undefined;
  deleterUser?: User;
  creatorUser?: User;
  lastModifierUser?: User;
  authenticationSource?: string | undefined;
  userName: string | undefined;
  tenantId?: number | undefined;
  emailAddress: string | undefined;
  name: string | undefined;
  surname: string | undefined;
  fullName?: string | undefined;
  password: string | undefined;
  emailConfirmationCode?: string | undefined;
  passwordResetCode?: string | undefined;
  lockoutEndDateUtc?: moment.Moment | undefined;
  accessFailedCount?: number;
  isLockoutEnabled?: boolean;
  phoneNumber?: string | undefined;
  isPhoneNumberConfirmed?: boolean;
  securityStamp?: string | undefined;
  isTwoFactorEnabled?: boolean;
  logins?: UserLogin[] | undefined;
  roles?: UserRole[] | undefined;
  claims?: UserClaim[] | undefined;
  permissions?: UserPermissionSetting[] | undefined;
  settings?: Setting[] | undefined;
  isEmailConfirmed?: boolean;
  isActive?: boolean;
  isDeleted?: boolean;
  deleterUserId?: number | undefined;
  deletionTime?: moment.Moment | undefined;
  lastModificationTime?: moment.Moment | undefined;
  lastModifierUserId?: number | undefined;
  creationTime?: moment.Moment;
  creatorUserId?: number | undefined;
  id?: number;
}

export class UserDto implements IUserDto {
  userName!: string | undefined;
  name!: string | undefined;
  surname!: string | undefined;
  emailAddress!: string | undefined;
  isActive?: boolean;
  fullName?: string | undefined;
  lastLoginTime?: moment.Moment | undefined;
  creationTime?: moment.Moment;
  password?: string | undefined;
  roleNames?: string[] | undefined;
  companyName?: string | undefined;
  birthdate?: moment.Moment | undefined;
  avatar?: string | undefined;
  gender?: string | undefined;
  student?: boolean;
  studentConfirmedDate?: moment.Moment | undefined;
  studentConfirmedBy?: User;
  studentLegitimation?: string | undefined;
  lastActivityDate?: moment.Moment | undefined;
  registrationDate?: moment.Moment | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  externalId?: string | undefined;
  intId?: number;
  externalSystem?: string | undefined;
  secondaryEmail?: string | undefined;
  addressPrintableHTML?: string | undefined;
  isJunior?: boolean;
  id?: number;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data['userName'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.emailAddress = _data['emailAddress'];
      this.isActive = _data['isActive'];
      this.fullName = _data['fullName'];
      this.lastLoginTime = _data['lastLoginTime'] ? moment(_data['lastLoginTime'].toString()) : <any>undefined;
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.password = _data['password'];
      if (Array.isArray(_data['roleNames'])) {
        this.roleNames = [] as any;
        for (let item of _data['roleNames']) this.roleNames!.push(item);
      }
      this.companyName = _data['companyName'];
      this.birthdate = _data['birthdate'] ? moment(_data['birthdate'].toString()) : <any>undefined;
      this.avatar = _data['avatar'];
      this.gender = _data['gender'];
      this.student = _data['student'];
      this.studentConfirmedDate = _data['studentConfirmedDate']
        ? moment(_data['studentConfirmedDate'].toString())
        : <any>undefined;
      this.studentConfirmedBy = _data['studentConfirmedBy'] ? User.fromJS(_data['studentConfirmedBy']) : <any>undefined;
      this.studentLegitimation = _data['studentLegitimation'];
      this.lastActivityDate = _data['lastActivityDate'] ? moment(_data['lastActivityDate'].toString()) : <any>undefined;
      this.registrationDate = _data['registrationDate'] ? moment(_data['registrationDate'].toString()) : <any>undefined;
      this.address = _data['address'];
      this.postalCode = _data['postalCode'];
      this.city = _data['city'];
      this.country = _data['country'];
      this.externalId = _data['externalId'];
      this.intId = _data['intId'];
      this.externalSystem = _data['externalSystem'];
      this.secondaryEmail = _data['secondaryEmail'];
      this.addressPrintableHTML = _data['addressPrintableHTML'];
      this.isJunior = _data['isJunior'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userName'] = this.userName;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['emailAddress'] = this.emailAddress;
    data['isActive'] = this.isActive;
    data['fullName'] = this.fullName;
    data['lastLoginTime'] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['password'] = this.password;
    if (Array.isArray(this.roleNames)) {
      data['roleNames'] = [];
      for (let item of this.roleNames) data['roleNames'].push(item);
    }
    data['companyName'] = this.companyName;
    data['birthdate'] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
    data['avatar'] = this.avatar;
    data['gender'] = this.gender;
    data['student'] = this.student;
    data['studentConfirmedDate'] = this.studentConfirmedDate ? this.studentConfirmedDate.toISOString() : <any>undefined;
    data['studentConfirmedBy'] = this.studentConfirmedBy ? this.studentConfirmedBy.toJSON() : <any>undefined;
    data['studentLegitimation'] = this.studentLegitimation;
    data['lastActivityDate'] = this.lastActivityDate ? this.lastActivityDate.toISOString() : <any>undefined;
    data['registrationDate'] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
    data['address'] = this.address;
    data['postalCode'] = this.postalCode;
    data['city'] = this.city;
    data['country'] = this.country;
    data['externalId'] = this.externalId;
    data['intId'] = this.intId;
    data['externalSystem'] = this.externalSystem;
    data['secondaryEmail'] = this.secondaryEmail;
    data['addressPrintableHTML'] = this.addressPrintableHTML;
    data['isJunior'] = this.isJunior;
    data['id'] = this.id;
    return data;
  }

  clone(): UserDto {
    const json = this.toJSON();
    let result = new UserDto();
    result.init(json);
    return result;
  }
}

export interface IUserDto {
  userName: string | undefined;
  name: string | undefined;
  surname: string | undefined;
  emailAddress: string | undefined;
  isActive?: boolean;
  fullName?: string | undefined;
  lastLoginTime?: moment.Moment | undefined;
  creationTime?: moment.Moment;
  password?: string | undefined;
  roleNames?: string[] | undefined;
  companyName?: string | undefined;
  birthdate?: moment.Moment | undefined;
  avatar?: string | undefined;
  gender?: string | undefined;
  student?: boolean;
  studentConfirmedDate?: moment.Moment | undefined;
  studentConfirmedBy?: User;
  studentLegitimation?: string | undefined;
  lastActivityDate?: moment.Moment | undefined;
  registrationDate?: moment.Moment | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  externalId?: string | undefined;
  intId?: number;
  externalSystem?: string | undefined;
  secondaryEmail?: string | undefined;
  addressPrintableHTML?: string | undefined;
  isJunior?: boolean;
  id?: number;
}

export class RegisterOutput implements IRegisterOutput {
  canLogin?: boolean;

  constructor(data?: IRegisterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canLogin = _data['canLogin'];
    }
  }

  static fromJS(data: any): RegisterOutput {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['canLogin'] = this.canLogin;
    return data;
  }

  clone(): RegisterOutput {
    const json = this.toJSON();
    let result = new RegisterOutput();
    result.init(json);
    return result;
  }
}

export interface IRegisterOutput {
  canLogin?: boolean;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
  theme!: string | undefined;

  constructor(data?: IChangeUiThemeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.theme = _data['theme'];
    }
  }

  static fromJS(data: any): ChangeUiThemeInput {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeUiThemeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['theme'] = this.theme;
    return data;
  }

  clone(): ChangeUiThemeInput {
    const json = this.toJSON();
    let result = new ChangeUiThemeInput();
    result.init(json);
    return result;
  }
}

export interface IChangeUiThemeInput {
  theme: string | undefined;
}

export enum ActionType {
  _1 = 1,
  _2 = 2,
  _10 = 10
}

export class DomainActionDto implements IDomainActionDto {
  title?: string | undefined;
  description?: string | undefined;
  type?: ActionType;
  command?: string | undefined;
  automatic?: boolean;
  active?: boolean;
  showUnits?: boolean;
  ruleExpression?: string | undefined;
  actionExpression?: string | undefined;
  messageTo?: string | undefined;
  messageFrom?: string | undefined;
  messageCC?: string | undefined;
  messageBcc?: string | undefined;
  messageSubject?: string | undefined;
  messageBody?: string | undefined;
  actionFailedMessage?: string | undefined;
  amount?: number;
  id?: number;

  constructor(data?: IDomainActionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.description = _data['description'];
      this.type = _data['type'];
      this.command = _data['command'];
      this.automatic = _data['automatic'];
      this.active = _data['active'];
      this.showUnits = _data['showUnits'];
      this.ruleExpression = _data['ruleExpression'];
      this.actionExpression = _data['actionExpression'];
      this.messageTo = _data['messageTo'];
      this.messageFrom = _data['messageFrom'];
      this.messageCC = _data['messageCC'];
      this.messageBcc = _data['messageBcc'];
      this.messageSubject = _data['messageSubject'];
      this.messageBody = _data['messageBody'];
      this.actionFailedMessage = _data['actionFailedMessage'];
      this.amount = _data['amount'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DomainActionDto {
    data = typeof data === 'object' ? data : {};
    let result = new DomainActionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['description'] = this.description;
    data['type'] = this.type;
    data['command'] = this.command;
    data['automatic'] = this.automatic;
    data['active'] = this.active;
    data['showUnits'] = this.showUnits;
    data['ruleExpression'] = this.ruleExpression;
    data['actionExpression'] = this.actionExpression;
    data['messageTo'] = this.messageTo;
    data['messageFrom'] = this.messageFrom;
    data['messageCC'] = this.messageCC;
    data['messageBcc'] = this.messageBcc;
    data['messageSubject'] = this.messageSubject;
    data['messageBody'] = this.messageBody;
    data['actionFailedMessage'] = this.actionFailedMessage;
    data['amount'] = this.amount;
    data['id'] = this.id;
    return data;
  }

  clone(): DomainActionDto {
    const json = this.toJSON();
    let result = new DomainActionDto();
    result.init(json);
    return result;
  }
}

export interface IDomainActionDto {
  title?: string | undefined;
  description?: string | undefined;
  type?: ActionType;
  command?: string | undefined;
  automatic?: boolean;
  active?: boolean;
  showUnits?: boolean;
  ruleExpression?: string | undefined;
  actionExpression?: string | undefined;
  messageTo?: string | undefined;
  messageFrom?: string | undefined;
  messageCC?: string | undefined;
  messageBcc?: string | undefined;
  messageSubject?: string | undefined;
  messageBody?: string | undefined;
  actionFailedMessage?: string | undefined;
  amount?: number;
  id?: number;
}

export class DomainActionDtoPagedResultDto implements IDomainActionDtoPagedResultDto {
  totalCount?: number;
  items?: DomainActionDto[] | undefined;

  constructor(data?: IDomainActionDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(DomainActionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DomainActionDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new DomainActionDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): DomainActionDtoPagedResultDto {
    const json = this.toJSON();
    let result = new DomainActionDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IDomainActionDtoPagedResultDto {
  totalCount?: number;
  items?: DomainActionDto[] | undefined;
}

export enum EventSearchRange {
  _0 = 0,
  _1 = 1,
  _2 = 2
}

export enum EventTypePriceCalculation {
  _0 = 0,
  _1 = 1,
  _2 = 2
}

export class EventTypeDto implements IEventTypeDto {
  title?: string | undefined;
  maxParticipants?: number;
  minParticipants?: number;
  priceCalculationType?: EventTypePriceCalculation;
  organisationId?: number;
  organisationShortName?: string | undefined;
  color?: string | undefined;
  cancellationTerms?: string | undefined;
  id?: number;

  constructor(data?: IEventTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.maxParticipants = _data['maxParticipants'];
      this.minParticipants = _data['minParticipants'];
      this.priceCalculationType = _data['priceCalculationType'];
      this.organisationId = _data['organisationId'];
      this.organisationShortName = _data['organisationShortName'];
      this.color = _data['color'];
      this.cancellationTerms = _data['cancellationTerms'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EventTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['maxParticipants'] = this.maxParticipants;
    data['minParticipants'] = this.minParticipants;
    data['priceCalculationType'] = this.priceCalculationType;
    data['organisationId'] = this.organisationId;
    data['organisationShortName'] = this.organisationShortName;
    data['color'] = this.color;
    data['cancellationTerms'] = this.cancellationTerms;
    data['id'] = this.id;
    return data;
  }

  clone(): EventTypeDto {
    const json = this.toJSON();
    let result = new EventTypeDto();
    result.init(json);
    return result;
  }
}

export interface IEventTypeDto {
  title?: string | undefined;
  maxParticipants?: number;
  minParticipants?: number;
  priceCalculationType?: EventTypePriceCalculation;
  organisationId?: number;
  organisationShortName?: string | undefined;
  color?: string | undefined;
  cancellationTerms?: string | undefined;
  id?: number;
}

export class EventResourceDto implements IEventResourceDto {
  eventId?: string;
  resourceId?: number;
  resourceTitle?: string | undefined;
  organisationTitle?: string | undefined;
  insertedAt?: moment.Moment | undefined;
  insertedByUsername?: string | undefined;
  updatedAt?: moment.Moment | undefined;
  updatedByUsername?: string | undefined;
  nrResourcesRequested?: number;
  resourceCost?: number;
  resourceRebate?: number;
  resourceCostNet?: number;
  id?: number;

  constructor(data?: IEventResourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.eventId = _data['eventId'];
      this.resourceId = _data['resourceId'];
      this.resourceTitle = _data['resourceTitle'];
      this.organisationTitle = _data['organisationTitle'];
      this.insertedAt = _data['insertedAt'] ? moment(_data['insertedAt'].toString()) : <any>undefined;
      this.insertedByUsername = _data['insertedByUsername'];
      this.updatedAt = _data['updatedAt'] ? moment(_data['updatedAt'].toString()) : <any>undefined;
      this.updatedByUsername = _data['updatedByUsername'];
      this.nrResourcesRequested = _data['nrResourcesRequested'];
      this.resourceCost = _data['resourceCost'];
      this.resourceRebate = _data['resourceRebate'];
      this.resourceCostNet = _data['resourceCostNet'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EventResourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventResourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['eventId'] = this.eventId;
    data['resourceId'] = this.resourceId;
    data['resourceTitle'] = this.resourceTitle;
    data['organisationTitle'] = this.organisationTitle;
    data['insertedAt'] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
    data['insertedByUsername'] = this.insertedByUsername;
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data['updatedByUsername'] = this.updatedByUsername;
    data['nrResourcesRequested'] = this.nrResourcesRequested;
    data['resourceCost'] = this.resourceCost;
    data['resourceRebate'] = this.resourceRebate;
    data['resourceCostNet'] = this.resourceCostNet;
    data['id'] = this.id;
    return data;
  }

  clone(): EventResourceDto {
    const json = this.toJSON();
    let result = new EventResourceDto();
    result.init(json);
    return result;
  }
}

export interface IEventResourceDto {
  eventId?: string;
  resourceId?: number;
  resourceTitle?: string | undefined;
  organisationTitle?: string | undefined;
  insertedAt?: moment.Moment | undefined;
  insertedByUsername?: string | undefined;
  updatedAt?: moment.Moment | undefined;
  updatedByUsername?: string | undefined;
  nrResourcesRequested?: number;
  resourceCost?: number;
  resourceRebate?: number;
  resourceCostNet?: number;
  id?: number;
}

export class EventParticipantActionDto implements IEventParticipantActionDto {
  domainActionId?: number;
  amount?: number;
  comment?: string | undefined;
  id?: number;

  constructor(data?: IEventParticipantActionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.domainActionId = _data['domainActionId'];
      this.amount = _data['amount'];
      this.comment = _data['comment'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EventParticipantActionDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventParticipantActionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['domainActionId'] = this.domainActionId;
    data['amount'] = this.amount;
    data['comment'] = this.comment;
    data['id'] = this.id;
    return data;
  }

  clone(): EventParticipantActionDto {
    const json = this.toJSON();
    let result = new EventParticipantActionDto();
    result.init(json);
    return result;
  }
}

export interface IEventParticipantActionDto {
  domainActionId?: number;
  amount?: number;
  comment?: string | undefined;
  id?: number;
}

export class EventEventParticipantDto implements IEventEventParticipantDto {
  participantId?: string | undefined;
  subscriptionInstanceId?: number | undefined;
  subscriptionTypeId?: number | undefined;
  cost?: number;
  actions?: EventParticipantActionDto[] | undefined;
  id?: number;

  constructor(data?: IEventEventParticipantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.participantId = _data['participantId'];
      this.subscriptionInstanceId = _data['subscriptionInstanceId'];
      this.subscriptionTypeId = _data['subscriptionTypeId'];
      this.cost = _data['cost'];
      if (Array.isArray(_data['actions'])) {
        this.actions = [] as any;
        for (let item of _data['actions']) this.actions!.push(EventParticipantActionDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EventEventParticipantDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventEventParticipantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['participantId'] = this.participantId;
    data['subscriptionInstanceId'] = this.subscriptionInstanceId;
    data['subscriptionTypeId'] = this.subscriptionTypeId;
    data['cost'] = this.cost;
    if (Array.isArray(this.actions)) {
      data['actions'] = [];
      for (let item of this.actions) data['actions'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }

  clone(): EventEventParticipantDto {
    const json = this.toJSON();
    let result = new EventEventParticipantDto();
    result.init(json);
    return result;
  }
}

export interface IEventEventParticipantDto {
  participantId?: string | undefined;
  subscriptionInstanceId?: number | undefined;
  subscriptionTypeId?: number | undefined;
  cost?: number;
  actions?: EventParticipantActionDto[] | undefined;
  id?: number;
}

export class EventDto implements IEventDto {
  allDay?: boolean;
  description?: string | undefined;
  start!: moment.Moment;
  end!: moment.Moment;
  recurrence?: boolean;
  readonly startEnd?: string | undefined;
  nrParticipants?: number;
  type?: number;
  location?: string | undefined;
  recurrenceRule?: string | undefined;
  recurrenceExceptions?: string | undefined;
  status?: number;
  subject?: string | undefined;
  reminderInfo?: string | undefined;
  resourceCost?: number | undefined;
  resourceIds?: string | undefined;
  eventTypeId?: number;
  eventType?: EventTypeDto;
  isPublic?: boolean;
  eventTypeTitle?: string | undefined;
  public?: boolean;
  tarifLevel?: number;
  participantId?: number | undefined;
  subscriptionInstanceId?: number | undefined;
  subscriptionTypeId?: number | undefined;
  selectedActions?: string | undefined;
  resources?: EventResourceDto[] | undefined;
  participants?: EventEventParticipantDto[] | undefined;
  actions?: EventParticipantActionDto[] | undefined;
  id?: string;

  constructor(data?: IEventDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.allDay = _data['allDay'];
      this.description = _data['description'];
      this.start = _data['start'] ? moment(_data['start'].toString()) : <any>undefined;
      this.end = _data['end'] ? moment(_data['end'].toString()) : <any>undefined;
      this.recurrence = _data['recurrence'];
      (<any>this).startEnd = _data['startEnd'];
      this.nrParticipants = _data['nrParticipants'];
      this.type = _data['type'];
      this.location = _data['location'];
      this.recurrenceRule = _data['recurrenceRule'];
      this.recurrenceExceptions = _data['recurrenceExceptions'];
      this.status = _data['status'];
      this.subject = _data['subject'];
      this.reminderInfo = _data['reminderInfo'];
      this.resourceCost = _data['resourceCost'];
      this.resourceIds = _data['resourceIds'];
      this.eventTypeId = _data['eventTypeId'];
      this.eventType = _data['eventType'] ? EventTypeDto.fromJS(_data['eventType']) : <any>undefined;
      this.isPublic = _data['isPublic'];
      this.eventTypeTitle = _data['eventTypeTitle'];
      this.public = _data['public'];
      this.tarifLevel = _data['tarifLevel'];
      this.participantId = _data['participantId'];
      this.subscriptionInstanceId = _data['subscriptionInstanceId'];
      this.subscriptionTypeId = _data['subscriptionTypeId'];
      this.selectedActions = _data['selectedActions'];
      if (Array.isArray(_data['resources'])) {
        this.resources = [] as any;
        for (let item of _data['resources']) this.resources!.push(EventResourceDto.fromJS(item));
      }
      if (Array.isArray(_data['participants'])) {
        this.participants = [] as any;
        for (let item of _data['participants']) this.participants!.push(EventEventParticipantDto.fromJS(item));
      }
      if (Array.isArray(_data['actions'])) {
        this.actions = [] as any;
        for (let item of _data['actions']) this.actions!.push(EventParticipantActionDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EventDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['allDay'] = this.allDay;
    data['description'] = this.description;
    data['start'] = this.start ? this.start.toISOString() : <any>undefined;
    data['end'] = this.end ? this.end.toISOString() : <any>undefined;
    data['recurrence'] = this.recurrence;
    data['startEnd'] = this.startEnd;
    data['nrParticipants'] = this.nrParticipants;
    data['type'] = this.type;
    data['location'] = this.location;
    data['recurrenceRule'] = this.recurrenceRule;
    data['recurrenceExceptions'] = this.recurrenceExceptions;
    data['status'] = this.status;
    data['subject'] = this.subject;
    data['reminderInfo'] = this.reminderInfo;
    data['resourceCost'] = this.resourceCost;
    data['resourceIds'] = this.resourceIds;
    data['eventTypeId'] = this.eventTypeId;
    data['eventType'] = this.eventType ? this.eventType.toJSON() : <any>undefined;
    data['isPublic'] = this.isPublic;
    data['eventTypeTitle'] = this.eventTypeTitle;
    data['public'] = this.public;
    data['tarifLevel'] = this.tarifLevel;
    data['participantId'] = this.participantId;
    data['subscriptionInstanceId'] = this.subscriptionInstanceId;
    data['subscriptionTypeId'] = this.subscriptionTypeId;
    data['selectedActions'] = this.selectedActions;
    if (Array.isArray(this.resources)) {
      data['resources'] = [];
      for (let item of this.resources) data['resources'].push(item.toJSON());
    }
    if (Array.isArray(this.participants)) {
      data['participants'] = [];
      for (let item of this.participants) data['participants'].push(item.toJSON());
    }
    if (Array.isArray(this.actions)) {
      data['actions'] = [];
      for (let item of this.actions) data['actions'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }

  clone(): EventDto {
    const json = this.toJSON();
    let result = new EventDto();
    result.init(json);
    return result;
  }
}

export interface IEventDto {
  allDay?: boolean;
  description?: string | undefined;
  start: moment.Moment;
  end: moment.Moment;
  recurrence?: boolean;
  startEnd?: string | undefined;
  nrParticipants?: number;
  type?: number;
  location?: string | undefined;
  recurrenceRule?: string | undefined;
  recurrenceExceptions?: string | undefined;
  status?: number;
  subject?: string | undefined;
  reminderInfo?: string | undefined;
  resourceCost?: number | undefined;
  resourceIds?: string | undefined;
  eventTypeId?: number;
  eventType?: EventTypeDto;
  isPublic?: boolean;
  eventTypeTitle?: string | undefined;
  public?: boolean;
  tarifLevel?: number;
  participantId?: number | undefined;
  subscriptionInstanceId?: number | undefined;
  subscriptionTypeId?: number | undefined;
  selectedActions?: string | undefined;
  resources?: EventResourceDto[] | undefined;
  participants?: EventEventParticipantDto[] | undefined;
  actions?: EventParticipantActionDto[] | undefined;
  id?: string;
}

export class EventDtoPagedResultDto implements IEventDtoPagedResultDto {
  totalCount?: number;
  items?: EventDto[] | undefined;

  constructor(data?: IEventDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(EventDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EventDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): EventDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EventDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEventDtoPagedResultDto {
  totalCount?: number;
  items?: EventDto[] | undefined;
}

export class EventTypeDtoPagedResultDto implements IEventTypeDtoPagedResultDto {
  totalCount?: number;
  items?: EventTypeDto[] | undefined;

  constructor(data?: IEventTypeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(EventTypeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EventTypeDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventTypeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): EventTypeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EventTypeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEventTypeDtoPagedResultDto {
  totalCount?: number;
  items?: EventTypeDto[] | undefined;
}

export class EventTypeTranslationDto implements IEventTypeTranslationDto {
  language?: string | undefined;
  title?: string | undefined;
  cancellationTerms?: string | undefined;

  constructor(data?: IEventTypeTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data['language'];
      this.title = _data['title'];
      this.cancellationTerms = _data['cancellationTerms'];
    }
  }

  static fromJS(data: any): EventTypeTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventTypeTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['language'] = this.language;
    data['title'] = this.title;
    data['cancellationTerms'] = this.cancellationTerms;
    return data;
  }

  clone(): EventTypeTranslationDto {
    const json = this.toJSON();
    let result = new EventTypeTranslationDto();
    result.init(json);
    return result;
  }
}

export interface IEventTypeTranslationDto {
  language?: string | undefined;
  title?: string | undefined;
  cancellationTerms?: string | undefined;
}

export class EventTypeCRUDDto implements IEventTypeCRUDDto {
  title?: string | undefined;
  maxParticipants?: number;
  minParticipants?: number;
  priceCalculationType?: EventTypePriceCalculation;
  organisationId?: number;
  organisationShortName?: string | undefined;
  color?: string | undefined;
  cancellationTerms?: string | undefined;
  translations?: EventTypeTranslationDto[] | undefined;
  id?: number;

  constructor(data?: IEventTypeCRUDDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.maxParticipants = _data['maxParticipants'];
      this.minParticipants = _data['minParticipants'];
      this.priceCalculationType = _data['priceCalculationType'];
      this.organisationId = _data['organisationId'];
      this.organisationShortName = _data['organisationShortName'];
      this.color = _data['color'];
      this.cancellationTerms = _data['cancellationTerms'];
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(EventTypeTranslationDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EventTypeCRUDDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventTypeCRUDDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['maxParticipants'] = this.maxParticipants;
    data['minParticipants'] = this.minParticipants;
    data['priceCalculationType'] = this.priceCalculationType;
    data['organisationId'] = this.organisationId;
    data['organisationShortName'] = this.organisationShortName;
    data['color'] = this.color;
    data['cancellationTerms'] = this.cancellationTerms;
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }

  clone(): EventTypeCRUDDto {
    const json = this.toJSON();
    let result = new EventTypeCRUDDto();
    result.init(json);
    return result;
  }
}

export interface IEventTypeCRUDDto {
  title?: string | undefined;
  maxParticipants?: number;
  minParticipants?: number;
  priceCalculationType?: EventTypePriceCalculation;
  organisationId?: number;
  organisationShortName?: string | undefined;
  color?: string | undefined;
  cancellationTerms?: string | undefined;
  translations?: EventTypeTranslationDto[] | undefined;
  id?: number;
}

export class EventTypeCRUDDtoPagedResultDto implements IEventTypeCRUDDtoPagedResultDto {
  totalCount?: number;
  items?: EventTypeCRUDDto[] | undefined;

  constructor(data?: IEventTypeCRUDDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(EventTypeCRUDDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EventTypeCRUDDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new EventTypeCRUDDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): EventTypeCRUDDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EventTypeCRUDDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEventTypeCRUDDtoPagedResultDto {
  totalCount?: number;
  items?: EventTypeCRUDDto[] | undefined;
}

export enum ResourceAllocationStrategy {
  _0 = 0,
  _1 = 1,
  _100 = 100
}

export class ResourceDto implements IResourceDto {
  title?: string | undefined;
  image?: string | undefined;
  color?: string | undefined;
  parentId?: number | undefined;
  allocationStrategy?: ResourceAllocationStrategy;
  allocationPriority?: number;
  needFreeEvent?: boolean;
  resourcePersonId?: number | undefined;
  knxGroupId?: string | undefined;
  knxDelayBeforeStart?: string | undefined;
  knxDelayAfterEnd?: string | undefined;
  displayHostName?: string | undefined;
  displayMacAddress?: string | undefined;
  ledgerAccountNoCredit?: string | undefined;
  bannerFile?: string | undefined;
  organisationId?: number;
  hasChildren?: boolean;
  children?: ResourceDto[] | undefined;
  id?: number;

  constructor(data?: IResourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.image = _data['image'];
      this.color = _data['color'];
      this.parentId = _data['parentId'];
      this.allocationStrategy = _data['allocationStrategy'];
      this.allocationPriority = _data['allocationPriority'];
      this.needFreeEvent = _data['needFreeEvent'];
      this.resourcePersonId = _data['resourcePersonId'];
      this.knxGroupId = _data['knxGroupId'];
      this.knxDelayBeforeStart = _data['knxDelayBeforeStart'];
      this.knxDelayAfterEnd = _data['knxDelayAfterEnd'];
      this.displayHostName = _data['displayHostName'];
      this.displayMacAddress = _data['displayMacAddress'];
      this.ledgerAccountNoCredit = _data['ledgerAccountNoCredit'];
      this.bannerFile = _data['bannerFile'];
      this.organisationId = _data['organisationId'];
      this.hasChildren = _data['hasChildren'];
      if (Array.isArray(_data['children'])) {
        this.children = [] as any;
        for (let item of _data['children']) this.children!.push(ResourceDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ResourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['image'] = this.image;
    data['color'] = this.color;
    data['parentId'] = this.parentId;
    data['allocationStrategy'] = this.allocationStrategy;
    data['allocationPriority'] = this.allocationPriority;
    data['needFreeEvent'] = this.needFreeEvent;
    data['resourcePersonId'] = this.resourcePersonId;
    data['knxGroupId'] = this.knxGroupId;
    data['knxDelayBeforeStart'] = this.knxDelayBeforeStart;
    data['knxDelayAfterEnd'] = this.knxDelayAfterEnd;
    data['displayHostName'] = this.displayHostName;
    data['displayMacAddress'] = this.displayMacAddress;
    data['ledgerAccountNoCredit'] = this.ledgerAccountNoCredit;
    data['bannerFile'] = this.bannerFile;
    data['organisationId'] = this.organisationId;
    data['hasChildren'] = this.hasChildren;
    if (Array.isArray(this.children)) {
      data['children'] = [];
      for (let item of this.children) data['children'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }

  clone(): ResourceDto {
    const json = this.toJSON();
    let result = new ResourceDto();
    result.init(json);
    return result;
  }
}

export interface IResourceDto {
  title?: string | undefined;
  image?: string | undefined;
  color?: string | undefined;
  parentId?: number | undefined;
  allocationStrategy?: ResourceAllocationStrategy;
  allocationPriority?: number;
  needFreeEvent?: boolean;
  resourcePersonId?: number | undefined;
  knxGroupId?: string | undefined;
  knxDelayBeforeStart?: string | undefined;
  knxDelayAfterEnd?: string | undefined;
  displayHostName?: string | undefined;
  displayMacAddress?: string | undefined;
  ledgerAccountNoCredit?: string | undefined;
  bannerFile?: string | undefined;
  organisationId?: number;
  hasChildren?: boolean;
  children?: ResourceDto[] | undefined;
  id?: number;
}

export class OrganisationDto implements IOrganisationDto {
  shortName?: string | undefined;
  title?: string | undefined;
  addressLine1?: string | undefined;
  addressLine2?: string | undefined;
  addressLine3?: string | undefined;
  addressLine4?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  addressPrintableHTML?: string | undefined;
  mailServiceApiKey?: string | undefined;
  mailServiceURL?: string | undefined;
  mailServiceListName?: string | undefined;
  ledgerAccountNoDebit?: string | undefined;
  esrAccountNoPrint?: string | undefined;
  esrAccountNo?: string | undefined;
  esrBankRef?: string | undefined;
  esrFilePath?: string | undefined;
  iban?: string | undefined;
  ibanPrint?: string | undefined;
  bankName?: string | undefined;
  phoneNr?: string | undefined;
  eMail?: string | undefined;
  contactName?: string | undefined;
  homePage?: string | undefined;
  currency?: string | undefined;
  ledgerPath?: string | undefined;
  ledgerAccountNoCommon?: string | undefined;
  ledgerVATCode?: string | undefined;
  vatNo?: string | undefined;
  bannerFile?: string | undefined;
  bannerDirectory?: string | undefined;
  resources?: ResourceDto[] | undefined;
  id?: number;

  constructor(data?: IOrganisationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shortName = _data['shortName'];
      this.title = _data['title'];
      this.addressLine1 = _data['addressLine1'];
      this.addressLine2 = _data['addressLine2'];
      this.addressLine3 = _data['addressLine3'];
      this.addressLine4 = _data['addressLine4'];
      this.postalCode = _data['postalCode'];
      this.city = _data['city'];
      this.country = _data['country'];
      this.addressPrintableHTML = _data['addressPrintableHTML'];
      this.mailServiceApiKey = _data['mailServiceApiKey'];
      this.mailServiceURL = _data['mailServiceURL'];
      this.mailServiceListName = _data['mailServiceListName'];
      this.ledgerAccountNoDebit = _data['ledgerAccountNoDebit'];
      this.esrAccountNoPrint = _data['esrAccountNoPrint'];
      this.esrAccountNo = _data['esrAccountNo'];
      this.esrBankRef = _data['esrBankRef'];
      this.esrFilePath = _data['esrFilePath'];
      this.iban = _data['iban'];
      this.ibanPrint = _data['ibanPrint'];
      this.bankName = _data['bankName'];
      this.phoneNr = _data['phoneNr'];
      this.eMail = _data['eMail'];
      this.contactName = _data['contactName'];
      this.homePage = _data['homePage'];
      this.currency = _data['currency'];
      this.ledgerPath = _data['ledgerPath'];
      this.ledgerAccountNoCommon = _data['ledgerAccountNoCommon'];
      this.ledgerVATCode = _data['ledgerVATCode'];
      this.vatNo = _data['vatNo'];
      this.bannerFile = _data['bannerFile'];
      this.bannerDirectory = _data['bannerDirectory'];
      if (Array.isArray(_data['resources'])) {
        this.resources = [] as any;
        for (let item of _data['resources']) this.resources!.push(ResourceDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): OrganisationDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrganisationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shortName'] = this.shortName;
    data['title'] = this.title;
    data['addressLine1'] = this.addressLine1;
    data['addressLine2'] = this.addressLine2;
    data['addressLine3'] = this.addressLine3;
    data['addressLine4'] = this.addressLine4;
    data['postalCode'] = this.postalCode;
    data['city'] = this.city;
    data['country'] = this.country;
    data['addressPrintableHTML'] = this.addressPrintableHTML;
    data['mailServiceApiKey'] = this.mailServiceApiKey;
    data['mailServiceURL'] = this.mailServiceURL;
    data['mailServiceListName'] = this.mailServiceListName;
    data['ledgerAccountNoDebit'] = this.ledgerAccountNoDebit;
    data['esrAccountNoPrint'] = this.esrAccountNoPrint;
    data['esrAccountNo'] = this.esrAccountNo;
    data['esrBankRef'] = this.esrBankRef;
    data['esrFilePath'] = this.esrFilePath;
    data['iban'] = this.iban;
    data['ibanPrint'] = this.ibanPrint;
    data['bankName'] = this.bankName;
    data['phoneNr'] = this.phoneNr;
    data['eMail'] = this.eMail;
    data['contactName'] = this.contactName;
    data['homePage'] = this.homePage;
    data['currency'] = this.currency;
    data['ledgerPath'] = this.ledgerPath;
    data['ledgerAccountNoCommon'] = this.ledgerAccountNoCommon;
    data['ledgerVATCode'] = this.ledgerVATCode;
    data['vatNo'] = this.vatNo;
    data['bannerFile'] = this.bannerFile;
    data['bannerDirectory'] = this.bannerDirectory;
    if (Array.isArray(this.resources)) {
      data['resources'] = [];
      for (let item of this.resources) data['resources'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }

  clone(): OrganisationDto {
    const json = this.toJSON();
    let result = new OrganisationDto();
    result.init(json);
    return result;
  }
}

export interface IOrganisationDto {
  shortName?: string | undefined;
  title?: string | undefined;
  addressLine1?: string | undefined;
  addressLine2?: string | undefined;
  addressLine3?: string | undefined;
  addressLine4?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  addressPrintableHTML?: string | undefined;
  mailServiceApiKey?: string | undefined;
  mailServiceURL?: string | undefined;
  mailServiceListName?: string | undefined;
  ledgerAccountNoDebit?: string | undefined;
  esrAccountNoPrint?: string | undefined;
  esrAccountNo?: string | undefined;
  esrBankRef?: string | undefined;
  esrFilePath?: string | undefined;
  iban?: string | undefined;
  ibanPrint?: string | undefined;
  bankName?: string | undefined;
  phoneNr?: string | undefined;
  eMail?: string | undefined;
  contactName?: string | undefined;
  homePage?: string | undefined;
  currency?: string | undefined;
  ledgerPath?: string | undefined;
  ledgerAccountNoCommon?: string | undefined;
  ledgerVATCode?: string | undefined;
  vatNo?: string | undefined;
  bannerFile?: string | undefined;
  bannerDirectory?: string | undefined;
  resources?: ResourceDto[] | undefined;
  id?: number;
}

export class OrganisationDtoPagedResultDto implements IOrganisationDtoPagedResultDto {
  totalCount?: number;
  items?: OrganisationDto[] | undefined;

  constructor(data?: IOrganisationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(OrganisationDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OrganisationDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrganisationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): OrganisationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new OrganisationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IOrganisationDtoPagedResultDto {
  totalCount?: number;
  items?: OrganisationDto[] | undefined;
}

export class PaymentRequestDto implements IPaymentRequestDto {
  readonly paymentGatewayId!: number;
  readonly organisationId!: number;
  readonly amount!: number;
  readonly additionalInfo!: string | undefined;
  readonly creditAccount?: string | undefined;
  readonly pairingId?: string | undefined;

  constructor(data?: IPaymentRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).paymentGatewayId = _data['paymentGatewayId'];
      (<any>this).organisationId = _data['organisationId'];
      (<any>this).amount = _data['amount'];
      (<any>this).additionalInfo = _data['additionalInfo'];
      (<any>this).creditAccount = _data['creditAccount'];
      (<any>this).pairingId = _data['pairingId'];
    }
  }

  static fromJS(data: any): PaymentRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentGatewayId'] = this.paymentGatewayId;
    data['organisationId'] = this.organisationId;
    data['amount'] = this.amount;
    data['additionalInfo'] = this.additionalInfo;
    data['creditAccount'] = this.creditAccount;
    data['pairingId'] = this.pairingId;
    return data;
  }

  clone(): PaymentRequestDto {
    const json = this.toJSON();
    let result = new PaymentRequestDto();
    result.init(json);
    return result;
  }
}

export interface IPaymentRequestDto {
  paymentGatewayId: number;
  organisationId: number;
  amount: number;
  additionalInfo: string | undefined;
  creditAccount?: string | undefined;
  pairingId?: string | undefined;
}

export class PaymentGatewayDto implements IPaymentGatewayDto {
  title?: string | undefined;
  description?: string | undefined;
  instructions?: string | undefined;
  ledgerAccountNoDebit?: string | undefined;
  initiationUrl?: string | undefined;
  localSuccessUrl?: string | undefined;
  localFailureUrl?: string | undefined;
  buttonImageUrl?: string | undefined;
  active?: boolean;
  id?: number;

  constructor(data?: IPaymentGatewayDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.description = _data['description'];
      this.instructions = _data['instructions'];
      this.ledgerAccountNoDebit = _data['ledgerAccountNoDebit'];
      this.initiationUrl = _data['initiationUrl'];
      this.localSuccessUrl = _data['localSuccessUrl'];
      this.localFailureUrl = _data['localFailureUrl'];
      this.buttonImageUrl = _data['buttonImageUrl'];
      this.active = _data['active'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PaymentGatewayDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentGatewayDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['description'] = this.description;
    data['instructions'] = this.instructions;
    data['ledgerAccountNoDebit'] = this.ledgerAccountNoDebit;
    data['initiationUrl'] = this.initiationUrl;
    data['localSuccessUrl'] = this.localSuccessUrl;
    data['localFailureUrl'] = this.localFailureUrl;
    data['buttonImageUrl'] = this.buttonImageUrl;
    data['active'] = this.active;
    data['id'] = this.id;
    return data;
  }

  clone(): PaymentGatewayDto {
    const json = this.toJSON();
    let result = new PaymentGatewayDto();
    result.init(json);
    return result;
  }
}

export interface IPaymentGatewayDto {
  title?: string | undefined;
  description?: string | undefined;
  instructions?: string | undefined;
  ledgerAccountNoDebit?: string | undefined;
  initiationUrl?: string | undefined;
  localSuccessUrl?: string | undefined;
  localFailureUrl?: string | undefined;
  buttonImageUrl?: string | undefined;
  active?: boolean;
  id?: number;
}

export class PaymentGatewayDtoPagedResultDto implements IPaymentGatewayDtoPagedResultDto {
  totalCount?: number;
  items?: PaymentGatewayDto[] | undefined;

  constructor(data?: IPaymentGatewayDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PaymentGatewayDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaymentGatewayDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentGatewayDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): PaymentGatewayDtoPagedResultDto {
    const json = this.toJSON();
    let result = new PaymentGatewayDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IPaymentGatewayDtoPagedResultDto {
  totalCount?: number;
  items?: PaymentGatewayDto[] | undefined;
}

export class ResourceDtoPagedResultDto implements IResourceDtoPagedResultDto {
  totalCount?: number;
  items?: ResourceDto[] | undefined;

  constructor(data?: IResourceDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ResourceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ResourceDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResourceDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): ResourceDtoPagedResultDto {
    const json = this.toJSON();
    let result = new ResourceDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IResourceDtoPagedResultDto {
  totalCount?: number;
  items?: ResourceDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
  name!: string | undefined;
  displayName!: string | undefined;
  normalizedName?: string | undefined;
  description?: string | undefined;
  grantedPermissions?: string[] | undefined;

  constructor(data?: ICreateRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.normalizedName = _data['normalizedName'];
      this.description = _data['description'];
      if (Array.isArray(_data['grantedPermissions'])) {
        this.grantedPermissions = [] as any;
        for (let item of _data['grantedPermissions']) this.grantedPermissions!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['normalizedName'] = this.normalizedName;
    data['description'] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data['grantedPermissions'] = [];
      for (let item of this.grantedPermissions) data['grantedPermissions'].push(item);
    }
    return data;
  }

  clone(): CreateRoleDto {
    const json = this.toJSON();
    let result = new CreateRoleDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRoleDto {
  name: string | undefined;
  displayName: string | undefined;
  normalizedName?: string | undefined;
  description?: string | undefined;
  grantedPermissions?: string[] | undefined;
}

export class RoleDto implements IRoleDto {
  name!: string | undefined;
  displayName!: string | undefined;
  normalizedName?: string | undefined;
  description?: string | undefined;
  grantedPermissions?: string[] | undefined;
  id?: number;

  constructor(data?: IRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.normalizedName = _data['normalizedName'];
      this.description = _data['description'];
      if (Array.isArray(_data['grantedPermissions'])) {
        this.grantedPermissions = [] as any;
        for (let item of _data['grantedPermissions']) this.grantedPermissions!.push(item);
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['normalizedName'] = this.normalizedName;
    data['description'] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data['grantedPermissions'] = [];
      for (let item of this.grantedPermissions) data['grantedPermissions'].push(item);
    }
    data['id'] = this.id;
    return data;
  }

  clone(): RoleDto {
    const json = this.toJSON();
    let result = new RoleDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDto {
  name: string | undefined;
  displayName: string | undefined;
  normalizedName?: string | undefined;
  description?: string | undefined;
  grantedPermissions?: string[] | undefined;
  id?: number;
}

export class RoleListDto implements IRoleListDto {
  name?: string | undefined;
  displayName?: string | undefined;
  isStatic?: boolean;
  isDefault?: boolean;
  creationTime?: moment.Moment;
  id?: number;

  constructor(data?: IRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.isStatic = _data['isStatic'];
      this.isDefault = _data['isDefault'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoleListDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['isStatic'] = this.isStatic;
    data['isDefault'] = this.isDefault;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }

  clone(): RoleListDto {
    const json = this.toJSON();
    let result = new RoleListDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDto {
  name?: string | undefined;
  displayName?: string | undefined;
  isStatic?: boolean;
  isDefault?: boolean;
  creationTime?: moment.Moment;
  id?: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
  items?: RoleListDto[] | undefined;

  constructor(data?: IRoleListDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(RoleListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleListDtoListResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleListDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleListDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleListDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDtoListResultDto {
  items?: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
  name?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  id?: number;

  constructor(data?: IPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['id'] = this.id;
    return data;
  }

  clone(): PermissionDto {
    const json = this.toJSON();
    let result = new PermissionDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDto {
  name?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  id?: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
  items?: PermissionDto[] | undefined;

  constructor(data?: IPermissionDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionDtoListResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): PermissionDtoListResultDto {
    const json = this.toJSON();
    let result = new PermissionDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDtoListResultDto {
  items?: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
  name!: string | undefined;
  displayName!: string | undefined;
  description?: string | undefined;
  isStatic?: boolean;
  id?: number;

  constructor(data?: IRoleEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.isStatic = _data['isStatic'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoleEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['isStatic'] = this.isStatic;
    data['id'] = this.id;
    return data;
  }

  clone(): RoleEditDto {
    const json = this.toJSON();
    let result = new RoleEditDto();
    result.init(json);
    return result;
  }
}

export interface IRoleEditDto {
  name: string | undefined;
  displayName: string | undefined;
  description?: string | undefined;
  isStatic?: boolean;
  id?: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
  name?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;

  constructor(data?: IFlatPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): FlatPermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new FlatPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    return data;
  }

  clone(): FlatPermissionDto {
    const json = this.toJSON();
    let result = new FlatPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IFlatPermissionDto {
  name?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
  role?: RoleEditDto;
  permissions?: FlatPermissionDto[] | undefined;
  grantedPermissionNames?: string[] | undefined;

  constructor(data?: IGetRoleForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.role = _data['role'] ? RoleEditDto.fromJS(_data['role']) : <any>undefined;
      if (Array.isArray(_data['permissions'])) {
        this.permissions = [] as any;
        for (let item of _data['permissions']) this.permissions!.push(FlatPermissionDto.fromJS(item));
      }
      if (Array.isArray(_data['grantedPermissionNames'])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames!.push(item);
      }
    }
  }

  static fromJS(data: any): GetRoleForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoleForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['role'] = this.role ? this.role.toJSON() : <any>undefined;
    if (Array.isArray(this.permissions)) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item.toJSON());
    }
    if (Array.isArray(this.grantedPermissionNames)) {
      data['grantedPermissionNames'] = [];
      for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
    }
    return data;
  }

  clone(): GetRoleForEditOutput {
    const json = this.toJSON();
    let result = new GetRoleForEditOutput();
    result.init(json);
    return result;
  }
}

export interface IGetRoleForEditOutput {
  role?: RoleEditDto;
  permissions?: FlatPermissionDto[] | undefined;
  grantedPermissionNames?: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
  totalCount?: number;
  items?: RoleDto[] | undefined;

  constructor(data?: IRoleDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RoleDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoPagedResultDto {
  totalCount?: number;
  items?: RoleDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
  version?: string | undefined;
  releaseDate?: moment.Moment;
  features?: { [key: string]: boolean } | undefined;

  constructor(data?: IApplicationInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data['version'];
      this.releaseDate = _data['releaseDate'] ? moment(_data['releaseDate'].toString()) : <any>undefined;
      if (_data['features']) {
        this.features = {} as any;
        for (let key in _data['features']) {
          if (_data['features'].hasOwnProperty(key)) this.features![key] = _data['features'][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['version'] = this.version;
    data['releaseDate'] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
    if (this.features) {
      data['features'] = {};
      for (let key in this.features) {
        if (this.features.hasOwnProperty(key)) data['features'][key] = this.features[key];
      }
    }
    return data;
  }

  clone(): ApplicationInfoDto {
    const json = this.toJSON();
    let result = new ApplicationInfoDto();
    result.init(json);
    return result;
  }
}

export interface IApplicationInfoDto {
  version?: string | undefined;
  releaseDate?: moment.Moment;
  features?: { [key: string]: boolean } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
  name?: string | undefined;
  surname?: string | undefined;
  userName?: string | undefined;
  emailAddress?: string | undefined;
  id?: number;

  constructor(data?: IUserLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserLoginInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['id'] = this.id;
    return data;
  }

  clone(): UserLoginInfoDto {
    const json = this.toJSON();
    let result = new UserLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface IUserLoginInfoDto {
  name?: string | undefined;
  surname?: string | undefined;
  userName?: string | undefined;
  emailAddress?: string | undefined;
  id?: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
  tenancyName?: string | undefined;
  name?: string | undefined;
  id?: number;

  constructor(data?: ITenantLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.name = _data['name'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TenantLoginInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['name'] = this.name;
    data['id'] = this.id;
    return data;
  }

  clone(): TenantLoginInfoDto {
    const json = this.toJSON();
    let result = new TenantLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface ITenantLoginInfoDto {
  tenancyName?: string | undefined;
  name?: string | undefined;
  id?: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
  application?: ApplicationInfoDto;
  user?: UserLoginInfoDto;
  tenant?: TenantLoginInfoDto;

  constructor(data?: IGetCurrentLoginInformationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.application = _data['application'] ? ApplicationInfoDto.fromJS(_data['application']) : <any>undefined;
      this.user = _data['user'] ? UserLoginInfoDto.fromJS(_data['user']) : <any>undefined;
      this.tenant = _data['tenant'] ? TenantLoginInfoDto.fromJS(_data['tenant']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetCurrentLoginInformationsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCurrentLoginInformationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['application'] = this.application ? this.application.toJSON() : <any>undefined;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    data['tenant'] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    return data;
  }

  clone(): GetCurrentLoginInformationsOutput {
    const json = this.toJSON();
    let result = new GetCurrentLoginInformationsOutput();
    result.init(json);
    return result;
  }
}

export interface IGetCurrentLoginInformationsOutput {
  application?: ApplicationInfoDto;
  user?: UserLoginInfoDto;
  tenant?: TenantLoginInfoDto;
}

export enum SubscriptionUnitType {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7,
  _8 = 8,
  _9 = 9
}

export class SubscriptionTypeDto implements ISubscriptionTypeDto {
  title?: string | undefined;
  description?: string | undefined;
  organisationId?: number;
  organisationTitle?: string | undefined;
  allowDelegation?: boolean;
  allowBookingsByUser?: boolean;
  selfServiceSubscription?: boolean;
  cost?: number;
  prepaid?: boolean;
  units?: SubscriptionUnitType;
  cancellationTerms?: string | undefined;
  renewalTerms?: string | undefined;
  pictureLink?: string | undefined;
  id?: number;

  constructor(data?: ISubscriptionTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.description = _data['description'];
      this.organisationId = _data['organisationId'];
      this.organisationTitle = _data['organisationTitle'];
      this.allowDelegation = _data['allowDelegation'];
      this.allowBookingsByUser = _data['allowBookingsByUser'];
      this.selfServiceSubscription = _data['selfServiceSubscription'];
      this.cost = _data['cost'];
      this.prepaid = _data['prepaid'];
      this.units = _data['units'];
      this.cancellationTerms = _data['cancellationTerms'];
      this.renewalTerms = _data['renewalTerms'];
      this.pictureLink = _data['pictureLink'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubscriptionTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['description'] = this.description;
    data['organisationId'] = this.organisationId;
    data['organisationTitle'] = this.organisationTitle;
    data['allowDelegation'] = this.allowDelegation;
    data['allowBookingsByUser'] = this.allowBookingsByUser;
    data['selfServiceSubscription'] = this.selfServiceSubscription;
    data['cost'] = this.cost;
    data['prepaid'] = this.prepaid;
    data['units'] = this.units;
    data['cancellationTerms'] = this.cancellationTerms;
    data['renewalTerms'] = this.renewalTerms;
    data['pictureLink'] = this.pictureLink;
    data['id'] = this.id;
    return data;
  }

  clone(): SubscriptionTypeDto {
    const json = this.toJSON();
    let result = new SubscriptionTypeDto();
    result.init(json);
    return result;
  }
}

export interface ISubscriptionTypeDto {
  title?: string | undefined;
  description?: string | undefined;
  organisationId?: number;
  organisationTitle?: string | undefined;
  allowDelegation?: boolean;
  allowBookingsByUser?: boolean;
  selfServiceSubscription?: boolean;
  cost?: number;
  prepaid?: boolean;
  units?: SubscriptionUnitType;
  cancellationTerms?: string | undefined;
  renewalTerms?: string | undefined;
  pictureLink?: string | undefined;
  id?: number;
}

export class SubscriptionDto implements ISubscriptionDto {
  subscriptionId?: number;
  subscriptionTypeId?: number;
  text?: string | undefined;
  active?: boolean;
  subscriptionType?: SubscriptionTypeDto;
  subscriptionSubscriberId?: string | undefined;
  subscriptionSubscriberIntId?: number;
  subscriptionSubscriberName?: string | undefined;
  subscriptionSubscriberFirstName?: string | undefined;
  subscriptionSubscriberLastName?: string | undefined;
  subscriptionSubscriberStudent?: string | undefined;
  subscriptionSubscriberJunior?: string | undefined;
  subscriptionSubscriberEmail?: string | undefined;
  subscriptionSubscriberAddressPrintableHTML?: string | undefined;
  cost?: number;
  rebate?: number;
  costNet?: number;
  ledgerAccountNoCredit?: string | undefined;
  startDate?: moment.Moment;
  expiryDate?: moment.Moment;
  confirmedDate?: moment.Moment | undefined;
  readonly startEnd?: string | undefined;
  postingsBalance?: number;
  postingsBalanced?: boolean;
  unitsBalance?: number;
  unitsStartBalance?: number;
  unitsBalanceBelowThreshold?: boolean;
  unitsBalanceTextHTML?: string | undefined;
  esrNr?: string | undefined;
  esrCodingLine?: string | undefined;
  readonly esrNrPrintable?: string | undefined;
  qrCodeData?: string | undefined;
  id?: number;

  constructor(data?: ISubscriptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.subscriptionId = _data['subscriptionId'];
      this.subscriptionTypeId = _data['subscriptionTypeId'];
      this.text = _data['text'];
      this.active = _data['active'];
      this.subscriptionType = _data['subscriptionType']
        ? SubscriptionTypeDto.fromJS(_data['subscriptionType'])
        : <any>undefined;
      this.subscriptionSubscriberId = _data['subscriptionSubscriberId'];
      this.subscriptionSubscriberIntId = _data['subscriptionSubscriberIntId'];
      this.subscriptionSubscriberName = _data['subscriptionSubscriberName'];
      this.subscriptionSubscriberFirstName = _data['subscriptionSubscriberFirstName'];
      this.subscriptionSubscriberLastName = _data['subscriptionSubscriberLastName'];
      this.subscriptionSubscriberStudent = _data['subscriptionSubscriberStudent'];
      this.subscriptionSubscriberJunior = _data['subscriptionSubscriberJunior'];
      this.subscriptionSubscriberEmail = _data['subscriptionSubscriberEmail'];
      this.subscriptionSubscriberAddressPrintableHTML = _data['subscriptionSubscriberAddressPrintableHTML'];
      this.cost = _data['cost'];
      this.rebate = _data['rebate'];
      this.costNet = _data['costNet'];
      this.ledgerAccountNoCredit = _data['ledgerAccountNoCredit'];
      this.startDate = _data['startDate'] ? moment(_data['startDate'].toString()) : <any>undefined;
      this.expiryDate = _data['expiryDate'] ? moment(_data['expiryDate'].toString()) : <any>undefined;
      this.confirmedDate = _data['confirmedDate'] ? moment(_data['confirmedDate'].toString()) : <any>undefined;
      (<any>this).startEnd = _data['startEnd'];
      this.postingsBalance = _data['postingsBalance'];
      this.postingsBalanced = _data['postingsBalanced'];
      this.unitsBalance = _data['unitsBalance'];
      this.unitsStartBalance = _data['unitsStartBalance'];
      this.unitsBalanceBelowThreshold = _data['unitsBalanceBelowThreshold'];
      this.unitsBalanceTextHTML = _data['unitsBalanceTextHTML'];
      this.esrNr = _data['esrNr'];
      this.esrCodingLine = _data['esrCodingLine'];
      (<any>this).esrNrPrintable = _data['esrNrPrintable'];
      this.qrCodeData = _data['qrCodeData'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubscriptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['subscriptionId'] = this.subscriptionId;
    data['subscriptionTypeId'] = this.subscriptionTypeId;
    data['text'] = this.text;
    data['active'] = this.active;
    data['subscriptionType'] = this.subscriptionType ? this.subscriptionType.toJSON() : <any>undefined;
    data['subscriptionSubscriberId'] = this.subscriptionSubscriberId;
    data['subscriptionSubscriberIntId'] = this.subscriptionSubscriberIntId;
    data['subscriptionSubscriberName'] = this.subscriptionSubscriberName;
    data['subscriptionSubscriberFirstName'] = this.subscriptionSubscriberFirstName;
    data['subscriptionSubscriberLastName'] = this.subscriptionSubscriberLastName;
    data['subscriptionSubscriberStudent'] = this.subscriptionSubscriberStudent;
    data['subscriptionSubscriberJunior'] = this.subscriptionSubscriberJunior;
    data['subscriptionSubscriberEmail'] = this.subscriptionSubscriberEmail;
    data['subscriptionSubscriberAddressPrintableHTML'] = this.subscriptionSubscriberAddressPrintableHTML;
    data['cost'] = this.cost;
    data['rebate'] = this.rebate;
    data['costNet'] = this.costNet;
    data['ledgerAccountNoCredit'] = this.ledgerAccountNoCredit;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['expiryDate'] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
    data['confirmedDate'] = this.confirmedDate ? this.confirmedDate.toISOString() : <any>undefined;
    data['startEnd'] = this.startEnd;
    data['postingsBalance'] = this.postingsBalance;
    data['postingsBalanced'] = this.postingsBalanced;
    data['unitsBalance'] = this.unitsBalance;
    data['unitsStartBalance'] = this.unitsStartBalance;
    data['unitsBalanceBelowThreshold'] = this.unitsBalanceBelowThreshold;
    data['unitsBalanceTextHTML'] = this.unitsBalanceTextHTML;
    data['esrNr'] = this.esrNr;
    data['esrCodingLine'] = this.esrCodingLine;
    data['esrNrPrintable'] = this.esrNrPrintable;
    data['qrCodeData'] = this.qrCodeData;
    data['id'] = this.id;
    return data;
  }

  clone(): SubscriptionDto {
    const json = this.toJSON();
    let result = new SubscriptionDto();
    result.init(json);
    return result;
  }
}

export interface ISubscriptionDto {
  subscriptionId?: number;
  subscriptionTypeId?: number;
  text?: string | undefined;
  active?: boolean;
  subscriptionType?: SubscriptionTypeDto;
  subscriptionSubscriberId?: string | undefined;
  subscriptionSubscriberIntId?: number;
  subscriptionSubscriberName?: string | undefined;
  subscriptionSubscriberFirstName?: string | undefined;
  subscriptionSubscriberLastName?: string | undefined;
  subscriptionSubscriberStudent?: string | undefined;
  subscriptionSubscriberJunior?: string | undefined;
  subscriptionSubscriberEmail?: string | undefined;
  subscriptionSubscriberAddressPrintableHTML?: string | undefined;
  cost?: number;
  rebate?: number;
  costNet?: number;
  ledgerAccountNoCredit?: string | undefined;
  startDate?: moment.Moment;
  expiryDate?: moment.Moment;
  confirmedDate?: moment.Moment | undefined;
  startEnd?: string | undefined;
  postingsBalance?: number;
  postingsBalanced?: boolean;
  unitsBalance?: number;
  unitsStartBalance?: number;
  unitsBalanceBelowThreshold?: boolean;
  unitsBalanceTextHTML?: string | undefined;
  esrNr?: string | undefined;
  esrCodingLine?: string | undefined;
  esrNrPrintable?: string | undefined;
  qrCodeData?: string | undefined;
  id?: number;
}

export class SubscriptionDtoPagedResultDto implements ISubscriptionDtoPagedResultDto {
  totalCount?: number;
  items?: SubscriptionDto[] | undefined;

  constructor(data?: ISubscriptionDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SubscriptionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SubscriptionDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): SubscriptionDtoPagedResultDto {
    const json = this.toJSON();
    let result = new SubscriptionDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ISubscriptionDtoPagedResultDto {
  totalCount?: number;
  items?: SubscriptionDto[] | undefined;
}

export class SubscriptionTypeDtoPagedResultDto implements ISubscriptionTypeDtoPagedResultDto {
  totalCount?: number;
  items?: SubscriptionTypeDto[] | undefined;

  constructor(data?: ISubscriptionTypeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SubscriptionTypeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SubscriptionTypeDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionTypeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): SubscriptionTypeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new SubscriptionTypeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ISubscriptionTypeDtoPagedResultDto {
  totalCount?: number;
  items?: SubscriptionTypeDto[] | undefined;
}

export class SubscriptionTypeTranslationDto implements ISubscriptionTypeTranslationDto {
  language?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  cancellationTerms?: string | undefined;
  renewalTerms?: string | undefined;

  constructor(data?: ISubscriptionTypeTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data['language'];
      this.title = _data['title'];
      this.description = _data['description'];
      this.cancellationTerms = _data['cancellationTerms'];
      this.renewalTerms = _data['renewalTerms'];
    }
  }

  static fromJS(data: any): SubscriptionTypeTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionTypeTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['language'] = this.language;
    data['title'] = this.title;
    data['description'] = this.description;
    data['cancellationTerms'] = this.cancellationTerms;
    data['renewalTerms'] = this.renewalTerms;
    return data;
  }

  clone(): SubscriptionTypeTranslationDto {
    const json = this.toJSON();
    let result = new SubscriptionTypeTranslationDto();
    result.init(json);
    return result;
  }
}

export interface ISubscriptionTypeTranslationDto {
  language?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  cancellationTerms?: string | undefined;
  renewalTerms?: string | undefined;
}

export class SubscriptionTypeCRUDDto implements ISubscriptionTypeCRUDDto {
  organisationId!: number;
  pictureLink?: string | undefined;
  allowDelegation?: boolean;
  allowBookingsByUser?: boolean;
  selfServiceSubscription?: boolean;
  autoActivate?: boolean;
  ledgerAccountNoCredit?: string | undefined;
  ledgerAccountNoDebit?: string | undefined;
  cost?: number;
  prepaid?: boolean;
  unitsStartBalance?: number;
  balanceThreshold?: number;
  unitPrice?: number;
  units?: SubscriptionUnitType;
  totalUnits?: number;
  autoRenew?: boolean;
  fixedTermEnd?: number;
  maxDurationDays?: number;
  rebateRoundExpression?: string | undefined;
  translations?: SubscriptionTypeTranslationDto[] | undefined;
  id?: number;

  constructor(data?: ISubscriptionTypeCRUDDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.organisationId = _data['organisationId'];
      this.pictureLink = _data['pictureLink'];
      this.allowDelegation = _data['allowDelegation'];
      this.allowBookingsByUser = _data['allowBookingsByUser'];
      this.selfServiceSubscription = _data['selfServiceSubscription'];
      this.autoActivate = _data['autoActivate'];
      this.ledgerAccountNoCredit = _data['ledgerAccountNoCredit'];
      this.ledgerAccountNoDebit = _data['ledgerAccountNoDebit'];
      this.cost = _data['cost'];
      this.prepaid = _data['prepaid'];
      this.unitsStartBalance = _data['unitsStartBalance'];
      this.balanceThreshold = _data['balanceThreshold'];
      this.unitPrice = _data['unitPrice'];
      this.units = _data['units'];
      this.totalUnits = _data['totalUnits'];
      this.autoRenew = _data['autoRenew'];
      this.fixedTermEnd = _data['fixedTermEnd'];
      this.maxDurationDays = _data['maxDurationDays'];
      this.rebateRoundExpression = _data['rebateRoundExpression'];
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(SubscriptionTypeTranslationDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubscriptionTypeCRUDDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionTypeCRUDDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['organisationId'] = this.organisationId;
    data['pictureLink'] = this.pictureLink;
    data['allowDelegation'] = this.allowDelegation;
    data['allowBookingsByUser'] = this.allowBookingsByUser;
    data['selfServiceSubscription'] = this.selfServiceSubscription;
    data['autoActivate'] = this.autoActivate;
    data['ledgerAccountNoCredit'] = this.ledgerAccountNoCredit;
    data['ledgerAccountNoDebit'] = this.ledgerAccountNoDebit;
    data['cost'] = this.cost;
    data['prepaid'] = this.prepaid;
    data['unitsStartBalance'] = this.unitsStartBalance;
    data['balanceThreshold'] = this.balanceThreshold;
    data['unitPrice'] = this.unitPrice;
    data['units'] = this.units;
    data['totalUnits'] = this.totalUnits;
    data['autoRenew'] = this.autoRenew;
    data['fixedTermEnd'] = this.fixedTermEnd;
    data['maxDurationDays'] = this.maxDurationDays;
    data['rebateRoundExpression'] = this.rebateRoundExpression;
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }

  clone(): SubscriptionTypeCRUDDto {
    const json = this.toJSON();
    let result = new SubscriptionTypeCRUDDto();
    result.init(json);
    return result;
  }
}

export interface ISubscriptionTypeCRUDDto {
  organisationId: number;
  pictureLink?: string | undefined;
  allowDelegation?: boolean;
  allowBookingsByUser?: boolean;
  selfServiceSubscription?: boolean;
  autoActivate?: boolean;
  ledgerAccountNoCredit?: string | undefined;
  ledgerAccountNoDebit?: string | undefined;
  cost?: number;
  prepaid?: boolean;
  unitsStartBalance?: number;
  balanceThreshold?: number;
  unitPrice?: number;
  units?: SubscriptionUnitType;
  totalUnits?: number;
  autoRenew?: boolean;
  fixedTermEnd?: number;
  maxDurationDays?: number;
  rebateRoundExpression?: string | undefined;
  translations?: SubscriptionTypeTranslationDto[] | undefined;
  id?: number;
}

export class SubscriptionTypeCRUDDtoPagedResultDto implements ISubscriptionTypeCRUDDtoPagedResultDto {
  totalCount?: number;
  items?: SubscriptionTypeCRUDDto[] | undefined;

  constructor(data?: ISubscriptionTypeCRUDDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SubscriptionTypeCRUDDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SubscriptionTypeCRUDDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionTypeCRUDDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): SubscriptionTypeCRUDDtoPagedResultDto {
    const json = this.toJSON();
    let result = new SubscriptionTypeCRUDDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ISubscriptionTypeCRUDDtoPagedResultDto {
  totalCount?: number;
  items?: SubscriptionTypeCRUDDto[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
  tenancyName!: string | undefined;
  name!: string | undefined;
  adminEmailAddress!: string | undefined;
  connectionString?: string | undefined;
  isActive?: boolean;

  constructor(data?: ICreateTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.name = _data['name'];
      this.adminEmailAddress = _data['adminEmailAddress'];
      this.connectionString = _data['connectionString'];
      this.isActive = _data['isActive'];
    }
  }

  static fromJS(data: any): CreateTenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['name'] = this.name;
    data['adminEmailAddress'] = this.adminEmailAddress;
    data['connectionString'] = this.connectionString;
    data['isActive'] = this.isActive;
    return data;
  }

  clone(): CreateTenantDto {
    const json = this.toJSON();
    let result = new CreateTenantDto();
    result.init(json);
    return result;
  }
}

export interface ICreateTenantDto {
  tenancyName: string | undefined;
  name: string | undefined;
  adminEmailAddress: string | undefined;
  connectionString?: string | undefined;
  isActive?: boolean;
}

export class TenantDto implements ITenantDto {
  tenancyName!: string | undefined;
  name!: string | undefined;
  isActive?: boolean;
  id?: number;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.name = _data['name'];
      this.isActive = _data['isActive'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['name'] = this.name;
    data['isActive'] = this.isActive;
    data['id'] = this.id;
    return data;
  }

  clone(): TenantDto {
    const json = this.toJSON();
    let result = new TenantDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDto {
  tenancyName: string | undefined;
  name: string | undefined;
  isActive?: boolean;
  id?: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
  totalCount?: number;
  items?: TenantDto[] | undefined;

  constructor(data?: ITenantDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TenantDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TenantDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): TenantDtoPagedResultDto {
    const json = this.toJSON();
    let result = new TenantDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDtoPagedResultDto {
  totalCount?: number;
  items?: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
  userNameOrEmailAddress!: string | undefined;
  password!: string | undefined;
  rememberClient?: boolean;

  constructor(data?: IAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userNameOrEmailAddress = _data['userNameOrEmailAddress'];
      this.password = _data['password'];
      this.rememberClient = _data['rememberClient'];
    }
  }

  static fromJS(data: any): AuthenticateModel {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userNameOrEmailAddress'] = this.userNameOrEmailAddress;
    data['password'] = this.password;
    data['rememberClient'] = this.rememberClient;
    return data;
  }

  clone(): AuthenticateModel {
    const json = this.toJSON();
    let result = new AuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateModel {
  userNameOrEmailAddress: string | undefined;
  password: string | undefined;
  rememberClient?: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
  accessToken?: string | undefined;
  encryptedAccessToken?: string | undefined;
  refreshToken?: string | undefined;
  expireInSeconds?: number;
  userId?: number;

  constructor(data?: IAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.encryptedAccessToken = _data['encryptedAccessToken'];
      this.refreshToken = _data['refreshToken'];
      this.expireInSeconds = _data['expireInSeconds'];
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): AuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['encryptedAccessToken'] = this.encryptedAccessToken;
    data['refreshToken'] = this.refreshToken;
    data['expireInSeconds'] = this.expireInSeconds;
    data['userId'] = this.userId;
    return data;
  }

  clone(): AuthenticateResultModel {
    const json = this.toJSON();
    let result = new AuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateResultModel {
  accessToken?: string | undefined;
  encryptedAccessToken?: string | undefined;
  refreshToken?: string | undefined;
  expireInSeconds?: number;
  userId?: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
  name?: string | undefined;
  clientId?: string | undefined;

  constructor(data?: IExternalLoginProviderInfoModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.clientId = _data['clientId'];
    }
  }

  static fromJS(data: any): ExternalLoginProviderInfoModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginProviderInfoModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['clientId'] = this.clientId;
    return data;
  }

  clone(): ExternalLoginProviderInfoModel {
    const json = this.toJSON();
    let result = new ExternalLoginProviderInfoModel();
    result.init(json);
    return result;
  }
}

export interface IExternalLoginProviderInfoModel {
  name?: string | undefined;
  clientId?: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
  authProvider!: string | undefined;
  providerKey!: string | undefined;
  providerAccessCode!: string | undefined;

  constructor(data?: IExternalAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authProvider = _data['authProvider'];
      this.providerKey = _data['providerKey'];
      this.providerAccessCode = _data['providerAccessCode'];
    }
  }

  static fromJS(data: any): ExternalAuthenticateModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalAuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['authProvider'] = this.authProvider;
    data['providerKey'] = this.providerKey;
    data['providerAccessCode'] = this.providerAccessCode;
    return data;
  }

  clone(): ExternalAuthenticateModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateModel {
  authProvider: string | undefined;
  providerKey: string | undefined;
  providerAccessCode: string | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
  accessToken?: string | undefined;
  encryptedAccessToken?: string | undefined;
  expireInSeconds?: number;
  waitingForActivation?: boolean;

  constructor(data?: IExternalAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.encryptedAccessToken = _data['encryptedAccessToken'];
      this.expireInSeconds = _data['expireInSeconds'];
      this.waitingForActivation = _data['waitingForActivation'];
    }
  }

  static fromJS(data: any): ExternalAuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['encryptedAccessToken'] = this.encryptedAccessToken;
    data['expireInSeconds'] = this.expireInSeconds;
    data['waitingForActivation'] = this.waitingForActivation;
    return data;
  }

  clone(): ExternalAuthenticateResultModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateResultModel {
  accessToken?: string | undefined;
  encryptedAccessToken?: string | undefined;
  expireInSeconds?: number;
  waitingForActivation?: boolean;
}

export class CreateUserDto implements ICreateUserDto {
  userName!: string | undefined;
  name!: string | undefined;
  surname!: string | undefined;
  emailAddress!: string | undefined;
  isActive?: boolean;
  roleNames?: string[] | undefined;
  password!: string | undefined;
  companyName?: string | undefined;
  birthdate?: moment.Moment | undefined;
  avatar?: string | undefined;
  gender?: string | undefined;
  student?: boolean;
  studentConfirmedDate?: moment.Moment | undefined;
  studentConfirmedById?: number;
  studentLegitimation?: string | undefined;
  lastActivityDate?: moment.Moment | undefined;
  registrationDate?: moment.Moment | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  externalId?: string | undefined;
  intId?: number;
  externalSystem?: string | undefined;
  secondaryEmail?: string | undefined;
  addressPrintableHTML?: string | undefined;
  isJunior?: boolean;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data['userName'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.emailAddress = _data['emailAddress'];
      this.isActive = _data['isActive'];
      if (Array.isArray(_data['roleNames'])) {
        this.roleNames = [] as any;
        for (let item of _data['roleNames']) this.roleNames!.push(item);
      }
      this.password = _data['password'];
      this.companyName = _data['companyName'];
      this.birthdate = _data['birthdate'] ? moment(_data['birthdate'].toString()) : <any>undefined;
      this.avatar = _data['avatar'];
      this.gender = _data['gender'];
      this.student = _data['student'];
      this.studentConfirmedDate = _data['studentConfirmedDate']
        ? moment(_data['studentConfirmedDate'].toString())
        : <any>undefined;
      this.studentConfirmedById = _data['studentConfirmedById'];
      this.studentLegitimation = _data['studentLegitimation'];
      this.lastActivityDate = _data['lastActivityDate'] ? moment(_data['lastActivityDate'].toString()) : <any>undefined;
      this.registrationDate = _data['registrationDate'] ? moment(_data['registrationDate'].toString()) : <any>undefined;
      this.address = _data['address'];
      this.postalCode = _data['postalCode'];
      this.city = _data['city'];
      this.country = _data['country'];
      this.externalId = _data['externalId'];
      this.intId = _data['intId'];
      this.externalSystem = _data['externalSystem'];
      this.secondaryEmail = _data['secondaryEmail'];
      this.addressPrintableHTML = _data['addressPrintableHTML'];
      this.isJunior = _data['isJunior'];
    }
  }

  static fromJS(data: any): CreateUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userName'] = this.userName;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['emailAddress'] = this.emailAddress;
    data['isActive'] = this.isActive;
    if (Array.isArray(this.roleNames)) {
      data['roleNames'] = [];
      for (let item of this.roleNames) data['roleNames'].push(item);
    }
    data['password'] = this.password;
    data['companyName'] = this.companyName;
    data['birthdate'] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
    data['avatar'] = this.avatar;
    data['gender'] = this.gender;
    data['student'] = this.student;
    data['studentConfirmedDate'] = this.studentConfirmedDate ? this.studentConfirmedDate.toISOString() : <any>undefined;
    data['studentConfirmedById'] = this.studentConfirmedById;
    data['studentLegitimation'] = this.studentLegitimation;
    data['lastActivityDate'] = this.lastActivityDate ? this.lastActivityDate.toISOString() : <any>undefined;
    data['registrationDate'] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
    data['address'] = this.address;
    data['postalCode'] = this.postalCode;
    data['city'] = this.city;
    data['country'] = this.country;
    data['externalId'] = this.externalId;
    data['intId'] = this.intId;
    data['externalSystem'] = this.externalSystem;
    data['secondaryEmail'] = this.secondaryEmail;
    data['addressPrintableHTML'] = this.addressPrintableHTML;
    data['isJunior'] = this.isJunior;
    return data;
  }

  clone(): CreateUserDto {
    const json = this.toJSON();
    let result = new CreateUserDto();
    result.init(json);
    return result;
  }
}

export interface ICreateUserDto {
  userName: string | undefined;
  name: string | undefined;
  surname: string | undefined;
  emailAddress: string | undefined;
  isActive?: boolean;
  roleNames?: string[] | undefined;
  password: string | undefined;
  companyName?: string | undefined;
  birthdate?: moment.Moment | undefined;
  avatar?: string | undefined;
  gender?: string | undefined;
  student?: boolean;
  studentConfirmedDate?: moment.Moment | undefined;
  studentConfirmedById?: number;
  studentLegitimation?: string | undefined;
  lastActivityDate?: moment.Moment | undefined;
  registrationDate?: moment.Moment | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  externalId?: string | undefined;
  intId?: number;
  externalSystem?: string | undefined;
  secondaryEmail?: string | undefined;
  addressPrintableHTML?: string | undefined;
  isJunior?: boolean;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
  items?: RoleDto[] | undefined;

  constructor(data?: IRoleDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleDtoListResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoListResultDto {
  items?: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
  languageName!: string | undefined;

  constructor(data?: IChangeUserLanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageName = _data['languageName'];
    }
  }

  static fromJS(data: any): ChangeUserLanguageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeUserLanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['languageName'] = this.languageName;
    return data;
  }

  clone(): ChangeUserLanguageDto {
    const json = this.toJSON();
    let result = new ChangeUserLanguageDto();
    result.init(json);
    return result;
  }
}

export interface IChangeUserLanguageDto {
  languageName: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
  currentPassword!: string | undefined;
  newPassword!: string | undefined;

  constructor(data?: IChangePasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data['currentPassword'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ChangePasswordDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['currentPassword'] = this.currentPassword;
    data['newPassword'] = this.newPassword;
    return data;
  }

  clone(): ChangePasswordDto {
    const json = this.toJSON();
    let result = new ChangePasswordDto();
    result.init(json);
    return result;
  }
}

export interface IChangePasswordDto {
  currentPassword: string | undefined;
  newPassword: string | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
  adminPassword!: string | undefined;
  userId!: number;
  newPassword!: string | undefined;

  constructor(data?: IResetPasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.adminPassword = _data['adminPassword'];
      this.userId = _data['userId'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ResetPasswordDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['adminPassword'] = this.adminPassword;
    data['userId'] = this.userId;
    data['newPassword'] = this.newPassword;
    return data;
  }

  clone(): ResetPasswordDto {
    const json = this.toJSON();
    let result = new ResetPasswordDto();
    result.init(json);
    return result;
  }
}

export interface IResetPasswordDto {
  adminPassword: string | undefined;
  userId: number;
  newPassword: string | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
  totalCount?: number;
  items?: UserDto[] | undefined;

  constructor(data?: IUserDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(UserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }

  clone(): UserDtoPagedResultDto {
    const json = this.toJSON();
    let result = new UserDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IUserDtoPagedResultDto {
  totalCount?: number;
  items?: UserDto[] | undefined;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
